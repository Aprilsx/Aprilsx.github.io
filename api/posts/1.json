{"total":20,"pageSize":10,"pageCount":2,"data":[{"title":"旧先生语","slug":"blooming180513","date":"2018-05-13T04:10:40.000Z","updated":"2018-05-13T04:59:44.000Z","comments":true,"path":"api/articles/blooming180513.json","excerpt":"<p style=\"text-align: center;\">❤</p>\n\n\n<p><br></p>\n<h4 id=\"🍀-一心冷暖无人问，奈何回首薄凉人\"><a href=\"#🍀-一心冷暖无人问，奈何回首薄凉人\" class=\"headerlink\" title=\"🍀   一心冷暖无人问，奈何回首薄凉人\"></a>🍀   一心冷暖无人问，奈何回首薄凉人</h4><p><br></p>\n<blockquote>\n<p>今日之感慨仅以勉励自己努力做个温暖的人。  </p>\n<p>让自己总保持合适的温度是一件不容易的事情，太热太凉都让人不舒服，时间久了，自己便觉得自己有些贱了。  </p>\n<p>其实不该这样想的，要知道，那属于自己的温度温暖他人固然是件很好的事情，但最重要的是温暖自己，不在悲观时放弃，不在乐观时窃喜。拥有自己的温度，在时间的路上走下去，总能少些无奈。</p>\n</blockquote>\n<p><br><br>","keywords":null,"cover":null,"content":null,"text":"❤<br>🍀   一心冷暖无人问，奈何回首薄凉人<br>今日之感慨仅以勉励自己努力做个温暖的人。  让自己总保持合适的温度是一件不容易的事情，太热太凉都让人不舒服，时间久了，自己便觉得自己有些贱了。  其实不该这样想的，要知道，那属于自己的温度温暖他人固然是件很好的事情，但最重","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"blooming","slug":"blooming","count":1,"path":"api/tags/blooming.json"}]},{"title":"Java.集合","slug":"sprouting180413c","date":"2018-04-13T09:43:24.000Z","updated":"2018-04-14T05:49:15.000Z","comments":true,"path":"api/articles/sprouting180413c.json","excerpt":"","keywords":null,"cover":"images/sprouting180413c_1.png","content":"<p></p><p style=\"text-align: center;\">❤</p><br><br><p></p>\n<h3 id=\"集合的出现是用来解决什么问题？\"><a href=\"#集合的出现是用来解决什么问题？\" class=\"headerlink\" title=\"集合的出现是用来解决什么问题？\"></a>集合的出现是用来解决什么问题？</h3><p>在实现方法的过程中，选择不同的数据结构会导致我们的实现风格以及性能存在着很大差异。所以在选择数据结构的时候，我们往往会考虑以下一些问题:</p>\n<ul>\n<li>我们需要快速地搜索成千上万的有序的数据项吗？</li>\n<li>我们需要快速地在有序的序列中间插入元素或删除元素吗？</li>\n<li>我们需要建立键与值之间的关联吗？</li>\n<li>…</li>\n</ul>\n<p><br></p>\n<h3 id=\"数据结构的相关知识\"><a href=\"#数据结构的相关知识\" class=\"headerlink\" title=\"数据结构的相关知识\"></a>数据结构的相关知识</h3><ol>\n<li><a href=\"https://blog.csdn.net/juanqinyang/article/details/51354293\" target=\"_blank\" rel=\"noopener\">参看“yang蜗牛”的博客了解队列——队列(queue)</a>。队列的两种实现分别是:<ul>\n<li>循环队列<br>  基于循环队列实现的循环数组是一个有界集合，即容量有限。</li>\n<li>链表<br>  基于链式队列实现的链表，不需要考虑队列是否已满，只要内存足够就可以一直分配空间。如果程序中要收集的对象数量没有上限，就最好使用链表。</li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/kay5804/article/details/5925555\" target=\"_blank\" rel=\"noopener\">参看“jspwind”的博客了解散列-散列(hash)</a><ul>\n<li>散列表(hashtable)可以快速查找所需要的对象</li>\n<li>散列表为每个对象计算了一个整数，称为散列码(hash code)</li>\n<li>在Java中，散列表用链表数组实现，每个列表被称为桶(bucket)</li>\n<li>桶数指的是用于收集具有相同散列值的数目<br>如果想要查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余得到保存这个元素的桶的索引，最后就可以很快找到这个元素了。这就是散列的用处。</li>\n</ul>\n</li>\n</ol>\n<p><br></p>\n<h3 id=\"迭代器（Iterator）\"><a href=\"#迭代器（Iterator）\" class=\"headerlink\" title=\"迭代器（Iterator）\"></a>迭代器（Iterator）</h3><ol>\n<li>迭代器对元素的访问顺序取决于被访问集合的类型，如ArrayList的访问是顺序的，又如HashSet的访问是无序的</li>\n<li>Iterator与Enumeration有类似方法，它们作用是一样的，但更多人喜欢Iterator，因为名字短</li>\n<li>Java迭代器中的查找操作与位置变更是紧密相连的，可以将Java迭代器认为是位于两个元素之间。当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。</li>\n<li>有个有用的推论是，可以将Iterator.next与InputStream.read看作为等效的。从数据流中读取一个字节，都会会自动地“消耗掉”这个字节。</li>\n<li>在Java中，参照第3点，迭代器的操作类似于“光标”的操作，绘制迭代器示意图对于理解迭代器的操作逻辑很有帮助</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">迭代器示意图例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">/ABC</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">A/BC</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">AX/BC</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 对应迭代器示意图的代码实现部分</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; a = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    a.add(<span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">    a.add(<span class=\"string\">\"B\"</span>);</span><br><span class=\"line\">    a.add(<span class=\"string\">\"C\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 获取迭代器</span></span><br><span class=\"line\">    ListIterator&lt;String&gt; aIter = a.listIterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( aIter.hasNext() ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( aIter.hasNext() ) &#123;</span><br><span class=\"line\">            aIter.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        aIter.add(<span class=\"string\">\"X\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"集合框架中接口的继承关系\"><a href=\"#集合框架中接口的继承关系\" class=\"headerlink\" title=\"集合框架中接口的继承关系.\"></a>集合框架中接口的继承关系.</h3><p><a href=\"https://www.cnblogs.com/jing99/p/7057245.html\" target=\"_blank\" rel=\"noopener\">图片引用“kosamino”的博客</a><br><a href=\"https://www.cnblogs.com/jing99/p/7057245.html\" target=\"_blank\" rel=\"noopener\"><img src=\"images/sprouting180413c_1.png\" alt=\"\"></a></p>\n<p><br></p>\n<blockquote>\n<p>  参考文献：<br>  [ 1 ] Java核心技术I p345-<br>  [ 2 ] <a href=\"https://blog.csdn.net/juanqinyang/article/details/51354293\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/juanqinyang/article/details/51354293</a><br><br></p>\n</blockquote>\n<p>🍀From Clover <a href=\"https://aprilsx.github.io/2018/04/13/sprouting180413c/\">https://aprilsx.github.io/2018/04/13/sprouting180413c/</a> </p>\n","text":"❤<br><br>集合的出现是用来解决什么问题？在实现方法的过程中，选择不同的数据结构会导致我们的实现风格以及性能存在着很大差异。所以在选择数据结构的时候，我们往往会考虑以下一些问题:我们需要快速地搜索成千上万的有序的数据项吗？我们需要快速地在有序的序列中间插入元素或删除元素吗？","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java.反射","slug":"sprouting180413b","date":"2018-04-13T05:53:16.000Z","updated":"2018-04-13T08:50:39.000Z","comments":true,"path":"api/articles/sprouting180413b.json","excerpt":"","keywords":null,"cover":null,"content":"<p></p><p style=\"text-align: center;\">❤</p><br><br><p></p>\n<h3 id=\"什么是反射？\"><a href=\"#什么是反射？\" class=\"headerlink\" title=\"什么是反射？\"></a>什么是反射？</h3><blockquote>\n<p>能够分析类能力的程序称为反射（reflection）。反射库提供了一个非常丰富且精心设计的工具类，以便编写能够动态操纵Java代码的程序。特别是在设计或运行中添加新类时，能够快速地应用开发工具动态地查询新添加类的能力。</p>\n</blockquote>\n<p><br></p>\n<h3 id=\"反射机制可以用来做什么？\"><a href=\"#反射机制可以用来做什么？\" class=\"headerlink\" title=\"反射机制可以用来做什么？\"></a>反射机制可以用来做什么？</h3><ul>\n<li>反射是一种功能强大且复杂的机制，使用它的主要人员是工具构造者，而不是应用程序员。<ul>\n<li>在运行时分析类</li>\n<li>在运行时查看对象</li>\n<li>实现通用的数组操作代码</li>\n<li>利用Method对象</li>\n</ul>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"Class类\"><a href=\"#Class类\" class=\"headerlink\" title=\"Class类\"></a>Class类</h3><blockquote>\n<p>在程序运行期间，Java运行时系统时钟为所有的对象维护一个被称为<b>运行时</b>的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行，这些信息可以通过专门的Java类来访问，而保存这些信息的类就是Class。</p>\n</blockquote>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Class对象方法测试</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">String <span class=\"built_in\">str</span> = new String();</span><br><span class=\"line\"></span><br><span class=\"line\">Class <span class=\"built_in\">className</span> = <span class=\"built_in\">str</span>.getClass();</span><br><span class=\"line\">System.out.println(<span class=\"built_in\">className</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"built_in\">className</span>.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"built_in\">className</span>.getSuperclass());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(Arrays.<span class=\"built_in\">toString</span>(<span class=\"built_in\">className</span>.getDeclaredMethods()));</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(Arrays.<span class=\"built_in\">toString</span>(<span class=\"built_in\">className</span>.getDeclaredClasses()));</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"built_in\">className</span>.getModifiers());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"built_in\">className</span>.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(Arrays.<span class=\"built_in\">toString</span>(<span class=\"built_in\">className</span>.getTypeParameters()));</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"built_in\">className</span>.getTypeName());</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"利用反射搞点事儿\"><a href=\"#利用反射搞点事儿\" class=\"headerlink\" title=\"利用反射搞点事儿\"></a>利用反射搞点事儿</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个例子利用反射实现了泛型数组的拷贝，很好的例子！</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">goodCopyOf</span><span class=\"params\">(Object a, <span class=\"keyword\">int</span> newLength)</span> </span>&#123;</span><br><span class=\"line\">    Class acl = a.getClass();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!acl.isArray()) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Class componetType = acl.getComponentType();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = Array.getLength(a);</span><br><span class=\"line\">    Object newArray = Array.newInstance(componetType, newLength);</span><br><span class=\"line\">    System.arraycopy(a, <span class=\"number\">0</span>, newArray, <span class=\"number\">0</span>, Math.min(length, newLength));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"调用任意方法\"><a href=\"#调用任意方法\" class=\"headerlink\" title=\"调用任意方法\"></a>调用任意方法</h3><p>在上代码之前，首先我们要清楚一个概念关于Method类。Method类类似于C语言中的函数指针，我们可以利用函数指针执行任意函数。</p>\n<ul>\n<li>假如我们已经获得了一个函数指针，那么如何去调用相对应的函数呢？这时候，反射机制就可以帮到我们，Mathod类中提供了一个invoke()方法，它便是利用反射机制来实现通过函数指针调用对应的函数。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 下面是invoke()方法签名，它就长这个样子</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 参数1: </span></span><br><span class=\"line\"><span class=\"comment\"> *      是一个隐式参数。</span></span><br><span class=\"line\"><span class=\"comment\"> *      对于静态方法，第一个参数可以被忽略，即可以将它设置为null</span></span><br><span class=\"line\"><span class=\"comment\"> * 剩余参数:</span></span><br><span class=\"line\"><span class=\"comment\"> *      是显示参数，如果没有显示参数就传递一个null</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 好像很难理解，我们来对照着获取函数指针的方法来看调用函数指针的方法就会明白</span></span><br><span class=\"line\"><span class=\"comment\"> *      String s = \"1\";</span></span><br><span class=\"line\"><span class=\"comment\"> *      Method m = s.getClass().getMethod(name, parameterTypes);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">Object <span class=\"title\">invoke</span><span class=\"params\">(Object obj, Object... args)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>现在我们知道了如何去调用函数指针对应的函数方法了。那么，另一问题？我们如何获得一个陌生类中的函数指针呢？<ol>\n<li>可以通过Class类中的getDeclareMethods方法，在返回的结果去找你想要的Method</li>\n<li>也可以通过调用这个类的getMethod方法得到</li>\n</ol>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>  参考文献：<br>  [ 1 ] Java核心技术I p190-207<br><br></p>\n</blockquote>\n<p>🍀From Clover <a href=\"https://aprilsx.github.io/2018/04/13/sprouting180413b/\">https://aprilsx.github.io/2018/04/13/sprouting180413b/</a> </p>\n","text":"❤<br><br>什么是反射？能够分析类能力的程序称为反射（reflection）。反射库提供了一个非常丰富且精心设计的工具类，以便编写能够动态操纵Java代码的程序。特别是在设计或运行中添加新类时，能够快速地应用开发工具动态地查询新添加类的能力。<br>反射机制可以用来做什么？","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java.代理模式(Proxy)","slug":"sprouting180413","date":"2018-04-13T02:30:30.000Z","updated":"2018-04-13T06:45:55.000Z","comments":true,"path":"api/articles/sprouting180413.json","excerpt":"","keywords":null,"cover":null,"content":"<p></p><p style=\"text-align: center;\">❤</p><p></p>\n<h3 id=\"代理模式是什么？\"><a href=\"#代理模式是什么？\" class=\"headerlink\" title=\"代理模式是什么？\"></a>代理模式是什么？</h3><blockquote>\n<p>代理(Proxy)是一种设计模式，提供了对目标对象另外的访问方式；即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。</p>\n<p>这里使用到编程中的一个思想：不要随意去修改别人已经写好的代码或者方法，如果需改修改，可以通过代理的方式来扩展该方法</p>\n</blockquote>\n<p><br></p>\n<h3 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h3><blockquote>\n<p>静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类.</p>\n<ul>\n<li>实现思路<ol>\n<li>创建公共父类或接口，使代理人和被代理人具有公共方法</li>\n<li>代理类中设置方法获取被代理对象</li>\n<li>代理类中重写被代理类中需要被扩展或更改的方法</li>\n<li>应用时，将被代理对象作为参数传递给代理对象，完成代理</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>代码部分<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Part.1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IUserDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Part.2 and .3</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span> <span class=\"keyword\">implements</span> <span class=\"title\">IUserDao</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Run as 10km/h! Too slow!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">IUserDao</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用父类或接口来接受对象，降低耦合度</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> IUserDao target;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDaoProxy</span><span class=\"params\">(IUserDao target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        target.run();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Propxy high up the speed to 20km/h! Fine!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Part.4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    UserDaoProxy proxy = <span class=\"keyword\">new</span> UserDaoProxy(<span class=\"keyword\">new</span> UserDao());</span><br><span class=\"line\">        proxy.run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"动态代理（JDK代理、接口代理）\"><a href=\"#动态代理（JDK代理、接口代理）\" class=\"headerlink\" title=\"动态代理（JDK代理、接口代理）\"></a>动态代理（JDK代理、接口代理）</h3><blockquote>\n<p>动态代理的代理对象不需要实现接口，它是通过JDK的API，动态的在内存中构建代理对象(需要我们指定创建代理对象／目标对象实现的接口的类型)</p>\n<p>动态代理中用到了invoke()，这是反射方面的知识，如果对反射机制没有一个认识的话，动态代理部分逻辑的实现会比较难理解！</p>\n</blockquote>\n<ul>\n<li><p>实现思路</p>\n<ol>\n<li>创建公共父类或接口，使代理人和被代理人具有公共方法</li>\n<li>设计代理工厂类，提供获取代理对象的方法。方法中主要利用Proxy.newProxyInstance()去创建代理实例，并实现对被代理类功能的重写或扩展</li>\n<li>创建被代理对象，通过代理工厂类获取代理对象，调用代理方法，完成代理</li>\n</ol>\n</li>\n<li><p>代码部分</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Part.1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IUserDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Part.2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ProxyFactory</span><span class=\"params\">(Object target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getProxyInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Proxy.newProxyInstance(</span><br><span class=\"line\">                <span class=\"comment\">// 参数1: loader</span></span><br><span class=\"line\">                <span class=\"comment\">// 为了获得原对象的类加载器</span></span><br><span class=\"line\">                target.getClass().getClassLoader(), </span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 参数2: interfaces</span></span><br><span class=\"line\">                <span class=\"comment\">// 为了获得原对象所实现的接口类型</span></span><br><span class=\"line\">                target.getClass().getInterfaces(), </span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 参数3: new InvocationHandler</span></span><br><span class=\"line\">                <span class=\"comment\">// 事件处理器</span></span><br><span class=\"line\">                <span class=\"comment\">// 执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"执行目标对象的方法并扩展\"</span>);</span><br><span class=\"line\">                        Object returnValue = method.invoke(target, args);</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"Propxy high up the speed to 20km/h! Fine!\"</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> returnValue;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Part.3</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    UserDao target = <span class=\"keyword\">new</span> UserDao();</span><br><span class=\"line\">    System.out.println(target.getClass());</span><br><span class=\"line\">    </span><br><span class=\"line\">    IUserDao proxy = (IUserDao) <span class=\"keyword\">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class=\"line\">    System.out.println(proxy.getClass());</span><br><span class=\"line\">    </span><br><span class=\"line\">    proxy.run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"Cglib代理（子类代理）\"><a href=\"#Cglib代理（子类代理）\" class=\"headerlink\" title=\"Cglib代理（子类代理）\"></a>Cglib代理（子类代理）</h3><ul>\n<li><a href=\"https://www.cnblogs.com/cenyu/p/6289209.html\" target=\"_blank\" rel=\"noopener\">请进入传送门</a></li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>  参考文献：<br>  [ 1 ] <a href=\"https://www.cnblogs.com/cenyu/p/6289209.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/cenyu/p/6289209.html</a><br>  [ 2 ] Java核心技术I p190-207<br><br></p>\n</blockquote>\n<p>🍀From Clover <a href=\"https://aprilsx.github.io/2018/04/13/sprouting180413/\">https://aprilsx.github.io/2018/04/13/sprouting180413/</a> </p>\n","text":"❤代理模式是什么？代理(Proxy)是一种设计模式，提供了对目标对象另外的访问方式；即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。这里使用到编程中的一个思想：不要随意去修改别人已经写好的代码或者方法，如果需改修改","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java.lambda","slug":"sprouting180412","date":"2018-04-12T06:27:09.000Z","updated":"2018-04-13T01:35:02.000Z","comments":true,"path":"api/articles/sprouting180412.json","excerpt":"<p></p><p style=\"text-align: center;\">❤</p><br><br><p></p>\n<h1 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a>lambda表达式</h1><p><a href=\"https://www.zhihu.com/question/27448188\" target=\"_blank\" rel=\"noopener\">数学中，带参数变量的表达式被称为lambda表达式。这背后有一小段故事。</a></p>\n<p><br></p>\n<h3 id=\"为什么引入lambda表达式？\"><a href=\"#为什么引入lambda表达式？\" class=\"headerlink\" title=\"为什么引入lambda表达式？\"></a>为什么引入lambda表达式？</h3><ul>\n<li>道理具简单，为了代码简洁，可读性高。lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。注意“以后”两个字，它意味着你在想用它的时候，在调它。这岂不是很方便么！了解Objective-C的一定会第一时间想到，这不就是block吗？是的，确实是一个意思。</li>\n</ul>","keywords":null,"cover":null,"content":null,"text":"❤<br><br>lambda表达式数学中，带参数变量的表达式被称为lambda表达式。这背后有一小段故事。<br>为什么引入lambda表达式？道理具简单，为了代码简洁，可读性高。lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。注意“以后”两个字，它意味着你在","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java.接口","slug":"sprouting180411","date":"2018-04-11T12:12:24.000Z","updated":"2018-04-13T01:45:01.000Z","comments":true,"path":"api/articles/sprouting180411.json","excerpt":"<p></p><p style=\"text-align: center;\">❤</p><br><br><p></p>\n<h1 id=\"接口技术\"><a href=\"#接口技术\" class=\"headerlink\" title=\"接口技术\"></a>接口技术</h1><p><br></p>\n<h3 id=\"接口技术是什么？\"><a href=\"#接口技术是什么？\" class=\"headerlink\" title=\"接口技术是什么？\"></a>接口技术是什么？</h3><ul>\n<li>接口技术主要用来描述类具有什么功能，而并不给出每个功能的具体实现。其具体功能的实现，应该交给遵从接口描述的类。一个类可以实现多个接口。接口中声明的方法默认使用的是public修饰符，也必须是public，这个很容易理解，因为你写接口就是让别人去实现的，你要是私有了，还有什么用！</li>\n</ul>","keywords":null,"cover":null,"content":null,"text":"❤<br><br>接口技术<br>接口技术是什么？接口技术主要用来描述类具有什么功能，而并不给出每个功能的具体实现。其具体功能的实现，应该交给遵从接口描述的类。一个类可以实现多个接口。接口中声明的方法默认使用的是public修饰符，也必须是public，这个很容易理解，因为你写接","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java.方法","slug":"sprouting180410","date":"2018-04-10T12:05:20.000Z","updated":"2018-04-13T01:41:49.000Z","comments":true,"path":"api/articles/sprouting180410.json","excerpt":"<p></p><p style=\"text-align: center;\">❤</p><p></p>\n<h1 id=\"关于方法\"><a href=\"#关于方法\" class=\"headerlink\" title=\"关于方法\"></a>关于方法</h1><p><br></p>\n<h3 id=\"什么是方法？\"><a href=\"#什么是方法？\" class=\"headerlink\" title=\"什么是方法？\"></a>什么是方法？</h3><blockquote>\n<p>编程语言中所说的方法，指的是能够处理事务的代码块。一般具有独立性，重用性，封装性等特点。C语言中叫它函数，Java中叫它方法。在面向对象的编程思想中，你也可以理解它为一种功能，编程者的你就好比上帝，你想让鸟会飞，便给它翅膀；你想让鱼会有，便给它尾鳍。</p>\n</blockquote>\n<p><br></p>\n<h3 id=\"方法长什么样子？\"><a href=\"#方法长什么样子？\" class=\"headerlink\" title=\"方法长什么样子？\"></a>方法长什么样子？</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修饰符  返回值类型  方法名（参数类型<span class=\"number\">1</span> 参数<span class=\"number\">1</span>, 参数类型<span class=\"number\">2</span> 参数<span class=\"number\">2</span>, ...）&#123;</span><br><span class=\"line\">    执行语句</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> 返回值;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最经典的便是main这个方法了<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"给鸟按翅膀，给鱼按鳍。\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// return;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所以方法里我们要关心下这些地方:</p>\n<ul>\n<li>修饰符<ul>\n<li>对访问权限进行限定。本质就是谁可以用，谁不能用的问题。</li>\n<li>控制内存空间区域存储的分配。</li>\n</ul>\n</li>\n<li>返回值类型<ul>\n<li>用于限定方法的返回值的数据类型。</li>\n</ul>\n</li>\n<li>方法名<ul>\n<li>起名字是有讲究的，比如setXXX，getXXX，构造器方法等等…</li>\n</ul>\n</li>\n<li>参数类型<ul>\n<li>用于接收调用方法时传入的数据</li>\n</ul>\n</li>\n<li>return关键字<ul>\n<li>用于结束方法以返回给调用者，在适当的时候可以提前结束。</li>\n</ul>\n</li>\n<li>返回值<ul>\n<li>被return返回的值，值就给了调用者。</li>\n</ul>\n</li>\n</ul>\n<p><br><br>","keywords":null,"cover":"/images/sprouting180410_1.png","content":null,"text":"❤关于方法<br>什么是方法？编程语言中所说的方法，指的是能够处理事务的代码块。一般具有独立性，重用性，封装性等特点。C语言中叫它函数，Java中叫它方法。在面向对象的编程思想中，你也可以理解它为一种功能，编程者的你就好比上帝，你想让鸟会飞，便给它翅膀；你想让鱼会有，便给它尾鳍。","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Eclipse Oxygen迷途之旅","slug":"sprouting180408","date":"2018-04-08T09:32:54.000Z","updated":"2018-04-13T01:41:38.000Z","comments":true,"path":"api/articles/sprouting180408.json","excerpt":"<p style=\"text-align: center;\">❤</p>\n\n<h3 id=\"Eclipse-Oxygen安装JavaEE\"><a href=\"#Eclipse-Oxygen安装JavaEE\" class=\"headerlink\" title=\"Eclipse Oxygen安装JavaEE\"></a>Eclipse Oxygen安装JavaEE</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/YIII_TIAN/article/details/78991782\" target=\"_blank\" rel=\"noopener\">移步“YIII_TIAN”的这篇博客的安装部分</a></p>\n</blockquote>\n<p><br></p>\n<h3 id=\"Eclipse-Oxygen创建第一个Servlet项目\"><a href=\"#Eclipse-Oxygen创建第一个Servlet项目\" class=\"headerlink\" title=\"Eclipse Oxygen创建第一个Servlet项目\"></a>Eclipse Oxygen创建第一个Servlet项目</h3><blockquote>\n<p><a href=\"https://www.cnblogs.com/kangjianwei101/p/5621750.html\" target=\"_blank\" rel=\"noopener\">移步“迷路的国王”的《Eclipse For JavaEE安装、配置、测试(win7_64bit)》</a></p>\n</blockquote>\n<p><br></p>\n<h3 id=\"Eclipse-Oxygen代码折叠-Collapes-All-展开-Expend-All-快捷键设置\"><a href=\"#Eclipse-Oxygen代码折叠-Collapes-All-展开-Expend-All-快捷键设置\" class=\"headerlink\" title=\"Eclipse Oxygen代码折叠(Collapes All)/展开(Expend All)快捷键设置\"></a>Eclipse Oxygen代码折叠(Collapes All)/展开(Expend All)快捷键设置</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/dliyuedong/article/details/12873651\" target=\"_blank\" rel=\"noopener\">移步“李跃东”的《eclipse代码折叠/展开之笔记本快捷键设置》</a><br>Mac下建议更改快捷键为 ‘control’ 加 ‘shift’ 加 ‘-‘ 和 ‘+’的组合，如图<br><img src=\"images/sprouting180408_1.png\" alt=\"\"><br><img src=\"images/sprouting180408_2.png\" alt=\"\"></p>\n</blockquote>","keywords":null,"cover":"images/sprouting180408_1.png","content":null,"text":"❤Eclipse Oxygen安装JavaEE移步“YIII_TIAN”的这篇博客的安装部分<br>Eclipse Oxygen创建第一个Servlet项目移步“迷路的国王”的《Eclipse For JavaEE安装、配置、测试(win7_64bit)》<br>Eclipse ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java.时间","slug":"sprouting180407b","date":"2018-04-07T10:01:18.000Z","updated":"2018-04-13T01:41:12.000Z","comments":true,"path":"api/articles/sprouting180407b.json","excerpt":"<p></p><p style=\"text-align: center;\">❤</p><br><img src=\"images/sprouting180407b_1.png\" alt=\"来自百度百科-格里高利历\"><p></p>\n<blockquote>\n<p>  时间的处理主要分为两种：<br>  一种作为量度主要被用来做计算，以ms为单位。<br>  另一种便是日期，被用来纪年。</p>\n</blockquote>\n<h3 id=\"时间的获取\"><a href=\"#时间的获取\" class=\"headerlink\" title=\"时间的获取\"></a>时间的获取</h3><ul>\n<li><p>Date()</p>\n<ol>\n<li><p>Date类中有好多废弃的方法，主要是因为这些方法破坏了类的封装性，使得原来被创建的Date对象再使用这些方法过后被改变。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Date();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>所以建议使用LocalDate</p>\n</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>LocalDate()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDate.now();</span><br><span class=\"line\">LocalTime.now();</span><br><span class=\"line\">LocalDateTime.now();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Calendar()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Calendar.getInstance();</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Calendar用来处理日期很方便</li>\n</ol>\n</li>\n<li><p>时间戳</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.currentTimeMillis()</span><br></pre></td></tr></table></figure>\n</li>\n</ul>","keywords":null,"cover":"images/sprouting180407b_1.png","content":null,"text":"❤<br> [Figure] 🍀From Clover https://aprilsx.github.io/2018/04/07/sprouting180407b/ ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java.数组","slug":"sprouting180407","date":"2018-04-07T05:11:34.000Z","updated":"2018-04-13T01:40:14.000Z","comments":true,"path":"api/articles/sprouting180407.json","excerpt":"<p></p><p style=\"text-align: center;\">❤</p><p></p>\n<blockquote>\n<p>直接对数组是比较麻烦的，最好是利用JDK中提供的工具类进行操作。这便要求我们第一步去处理数组，将数组转换为可变对象数组，然后再进行操作会变的更加方便。但是有时候我们还需要考虑数据的安全性，因此数组转换后还是需要再考虑其处理结果的存储形势。</p>\n</blockquote>\n<p><br></p>\n<h3 id=\"数组的排序及元素查找\"><a href=\"#数组的排序及元素查找\" class=\"headerlink\" title=\"数组的排序及元素查找\"></a>数组的排序及元素查找</h3><ul>\n<li><p>sort()</p>\n<ol>\n<li>利用Arrays工具类的sort()便可轻松实现对数组的排序。值得注意的是，该排序算法DualPivotQuicksort自JDK1.7之后再次做了优化。</li>\n<li><a href=\"https://stackoverflow.com/questions/20917617/whats-the-difference-of-dual-pivot-quick-sort-and-quick-sort\" target=\"_blank\" rel=\"noopener\">关于DualPivotQuicksort</a></li>\n</ol>\n</li>\n<li><p>parallelSort()</p>\n<ol>\n<li>并行排序在sort()再次进行了优化，主要考虑的是CPU资源占用问题。对线程的合理规划使得我们在处理大数据排序时又节省了一些时间。<a href=\"https://www.cnblogs.com/princessd8251/articles/5186704.html\" target=\"_blank\" rel=\"noopener\">大致比较结果</a></li>\n</ol>\n</li>\n<li><a href=\"https://www.cnblogs.com/whgk/p/6596787.html\" target=\"_blank\" rel=\"noopener\">Java实现7种排序</a></li>\n<li><p>binarySearch()</p>\n<ol>\n<li>在数组已排序完成的前提下！利用二分法查找能够快速获得想要查找的元素。</li>\n</ol>\n</li>\n<li><p>contains()</p>\n<ol>\n<li>查看数组中是否包含指定元素。</li>\n</ol>\n</li>\n</ul>","keywords":null,"cover":null,"content":null,"text":"❤直接对数组是比较麻烦的，最好是利用JDK中提供的工具类进行操作。这便要求我们第一步去处理数组，将数组转换为可变对象数组，然后再进行操作会变的更加方便。但是有时候我们还需要考虑数据的安全性，因此数组转换后还是需要再考虑其处理结果的存储形势。<br>数组的排序及元素查找sort()","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]}]}