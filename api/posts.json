{"total":12,"pageSize":10,"pageCount":2,"data":[{"title":"Java.时间","slug":"sprouting180407b","date":"2018-04-07T10:01:18.000Z","updated":"2018-04-07T11:07:56.000Z","comments":true,"path":"api/articles/sprouting180407b.json","excerpt":"","keywords":null,"cover":"images/sprouting180407b_1.png","content":"<p></p><p style=\"text-align: center;\">❤</p><br><img src=\"images/sprouting180407b_1.png\" alt=\"来自百度百科-格里高利历\"><p></p>\n<blockquote>\n<p>  时间的处理主要分为两种：<br>  一种作为量度主要被用来做计算，以ms为单位。<br>  另一种便是日期，被用来纪年。</p>\n</blockquote>\n<h3 id=\"时间的获取\"><a href=\"#时间的获取\" class=\"headerlink\" title=\"时间的获取\"></a>时间的获取</h3><ul>\n<li><p>Date()</p>\n<ol>\n<li><p>Date类中有好多废弃的方法，主要是因为这些方法破坏了类的封装性，使得原来被创建的Date对象再使用这些方法过后被改变。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Date();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>所以建议使用LocalDate</p>\n</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>LocalDate()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDate.now();</span><br><span class=\"line\">LocalTime.now();</span><br><span class=\"line\">LocalDateTime.now();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Calendar()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Calendar.getInstance();</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Calendar用来处理日期很方便</li>\n</ol>\n</li>\n<li><p>时间戳</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.currentTimeMillis()</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"时间的格式化\"><a href=\"#时间的格式化\" class=\"headerlink\" title=\"时间的格式化\"></a>时间的格式化</h3><ul>\n<li><p>DateFormat()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DateFormat aFormat = DateFormat.getDateInstance();</span><br><span class=\"line\">aFormat.format(&lt;Date&gt;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>SimpleDateFormat()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SimpleDateFormat.getDateInstance();</span><br><span class=\"line\"><span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"G yyyy年MM月dd日:今天是yyyy年的第D天,E\"</span>);</span><br><span class=\"line\">aSimpleDateFormat.format(&lt;Date&gt;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>  参考文献：</p>\n<p><br></p>\n</blockquote>\n<p>🍀From Clover <a href=\"https://aprilsx.github.io/2018/04/07/sprouting180407b/\">https://aprilsx.github.io/2018/04/07/sprouting180407b/</a> </p>\n","text":"❤<br> [Figure] 🍀From Clover https://aprilsx.github.io/2018/04/07/sprouting180407b/ ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":10,"path":"api/tags/sprouting.json"}]},{"title":"Java.数组","slug":"sprouting180407","date":"2018-04-07T05:11:34.000Z","updated":"2018-04-07T09:54:09.000Z","comments":true,"path":"api/articles/sprouting180407.json","excerpt":"","keywords":null,"cover":null,"content":"<p></p><p style=\"text-align: center;\">❤</p><p></p>\n<blockquote>\n<p>直接对数组是比较麻烦的，最好是利用JDK中提供的工具类进行操作。这便要求我们第一步去处理数组，将数组转换为可变对象数组，然后再进行操作会变的更加方便。但是有时候我们还需要考虑数据的安全性，因此数组转换后还是需要再考虑其处理结果的存储形势。</p>\n</blockquote>\n<p><br></p>\n<h3 id=\"数组的排序及元素查找\"><a href=\"#数组的排序及元素查找\" class=\"headerlink\" title=\"数组的排序及元素查找\"></a>数组的排序及元素查找</h3><ul>\n<li><p>sort()</p>\n<ol>\n<li>利用Arrays工具类的sort()便可轻松实现对数组的排序。值得注意的是，该排序算法DualPivotQuicksort自JDK1.7之后再次做了优化。</li>\n<li><a href=\"https://stackoverflow.com/questions/20917617/whats-the-difference-of-dual-pivot-quick-sort-and-quick-sort\" target=\"_blank\" rel=\"noopener\">关于DualPivotQuicksort</a></li>\n</ol>\n</li>\n<li><p>parallelSort()</p>\n<ol>\n<li>并行排序在sort()再次进行了优化，主要考虑的是CPU资源占用问题。对线程的合理规划使得我们在处理大数据排序时又节省了一些时间。<a href=\"https://www.cnblogs.com/princessd8251/articles/5186704.html\" target=\"_blank\" rel=\"noopener\">大致比较结果</a></li>\n</ol>\n</li>\n<li><a href=\"https://www.cnblogs.com/whgk/p/6596787.html\" target=\"_blank\" rel=\"noopener\">Java实现7种排序</a></li>\n<li><p>binarySearch()</p>\n<ol>\n<li>在数组已排序完成的前提下！利用二分法查找能够快速获得想要查找的元素。</li>\n</ol>\n</li>\n<li><p>contains()</p>\n<ol>\n<li>查看数组中是否包含指定元素。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"数组添加元素\"><a href=\"#数组添加元素\" class=\"headerlink\" title=\"数组添加元素\"></a>数组添加元素</h3><ul>\n<li><p>System.arrayCopy()</p>\n<ol>\n<li>由于数组创建之后的空间无法自动扩容，因此需要人去干涉。利用数组复制原理，开辟更大的destination数组后，便可将source数组分段或一次性的拷贝入扩容后的destination中，实现数组元素的插入、追加、合并、扩容等。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.arraycopy(src, srcPos, dest, destPos, length);</span><br><span class=\"line\"><span class=\"comment\">// 伪代码</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> length = original.length;</span><br><span class=\"line\"><span class=\"keyword\">int</span> destination[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length + <span class=\"number\">1</span>];</span><br><span class=\"line\">System.arraycopy(original, <span class=\"number\">0</span>, destination, <span class=\"number\">0</span>, index);</span><br><span class=\"line\">destination[index] = element;</span><br><span class=\"line\">System.arraycopy(original, index, destination, index + <span class=\"number\">1</span>, length - index);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"数组反转\"><a href=\"#数组反转\" class=\"headerlink\" title=\"数组反转\"></a>数组反转</h3><ul>\n<li><p>reverse()</p>\n<ol>\n<li>Collections工具类的reverse()主要操作的是List对象，所以使用前要<a href=\"https://jingyan.baidu.com/album/86f4a73e607f2937d7526972.html?picindex=2\" target=\"_blank\" rel=\"noopener\">对数组进行转化</a>，小心陷阱，参考所附文献。</li>\n</ol>\n</li>\n<li><p>reverseOrder()</p>\n<ol>\n<li>如果要对对象数组进行反序，在我们实现了一个Comparator的前提下，我们可以通过该方法获得一个反序的比较器</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"数组合并\"><a href=\"#数组合并\" class=\"headerlink\" title=\"数组合并\"></a>数组合并</h3><ul>\n<li>addAll()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a[] = &#123; <span class=\"string\">\"A\"</span>, <span class=\"string\">\"E\"</span>, <span class=\"string\">\"I\"</span> &#125;;</span><br><span class=\"line\">String b[] = &#123; <span class=\"string\">\"O\"</span>, <span class=\"string\">\"U\"</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 数组转List</span></span><br><span class=\"line\">List list = <span class=\"keyword\">new</span> ArrayList(Arrays.asList(a));</span><br><span class=\"line\">list.addAll(Arrays.asList(b));</span><br><span class=\"line\">Object[] c = list.toArray();</span><br><span class=\"line\">System.out.println(Arrays.toString(c));</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组填充\"><a href=\"#数组填充\" class=\"headerlink\" title=\"数组填充\"></a>数组填充</h3><ul>\n<li><p>fill()</p>\n<ol>\n<li>将数组内元素进行批量的填充，填充类型可以是对象类型，在数组初始化时很方便。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"数组元素的删除\"><a href=\"#数组元素的删除\" class=\"headerlink\" title=\"数组元素的删除\"></a>数组元素的删除</h3><ul>\n<li>数组转List</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 暂时没搞懂</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] src = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">List&lt;Integer&gt; list = Arrays.stream( src ).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<ul>\n<li>clear()清除所有List中的元素</li>\n<li>remove()删除指定元素</li>\n<li>removeAll()数组求差集</li>\n<li>retainAll()数组求交集</li>\n</ul>\n<h3 id=\"数组相等性判断\"><a href=\"#数组相等性判断\" class=\"headerlink\" title=\"数组相等性判断\"></a>数组相等性判断</h3><ul>\n<li><p>equals()</p>\n<ol>\n<li>源代码中重写了equals方法，使得数组具有了元素的判断能力。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns &#123;<span class=\"doctag\">@code</span> true&#125; if the two specified arrays of ints are</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both</span></span><br><span class=\"line\"><span class=\"comment\"> * arrays contain the same number of elements, and all corresponding pairs</span></span><br><span class=\"line\"><span class=\"comment\"> * of elements in the two arrays are equal.  In other words, two arrays</span></span><br><span class=\"line\"><span class=\"comment\"> * are equal if they contain the same elements in the same order.  Also,</span></span><br><span class=\"line\"><span class=\"comment\"> * two array references are considered equal if both are &#123;<span class=\"doctag\">@code</span> null&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a one array to be tested for equality</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a2 the other array to be tested for equality</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> true&#125; if the two arrays are equal</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span>[] a2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a==a2)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a==<span class=\"keyword\">null</span> || a2==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a2.length != length)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ArraysSupport.mismatch(a, a2, length) &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>  参考文献：<br>  [ 1 ] <a href=\"https://www.cnblogs.com/princessd8251/articles/5186704.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/princessd8251/articles/5186704.html</a><br>  [ 2 ] <a href=\"https://www.cnblogs.com/whgk/p/6596787.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/whgk/p/6596787.html</a><br>  [ 3 ] <a href=\"https://blog.csdn.net/ke_zhang_123/article/details/75968907\" target=\"_blank\" rel=\"noopener\">asList存在的问题</a><br>  [ 4 ] <a href=\"https://blog.csdn.net/chenleixing/article/details/43775127\" target=\"_blank\" rel=\"noopener\">关于Arrays.asList你一定要知道的陷阱</a><br><br></p>\n</blockquote>\n<p>🍀From Clover <a href=\"https://aprilsx.github.io/2018/04/07/sprouting180407/\">https://aprilsx.github.io/2018/04/07/sprouting180407/</a> </p>\n","text":"❤直接对数组是比较麻烦的，最好是利用JDK中提供的工具类进行操作。这便要求我们第一步去处理数组，将数组转换为可变对象数组，然后再进行操作会变的更加方便。但是有时候我们还需要考虑数据的安全性，因此数组转换后还是需要再考虑其处理结果的存储形势。<br>数组的排序及元素查找sort()","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":10,"path":"api/tags/sprouting.json"}]},{"title":"Java.字符串","slug":"sprouting180404","date":"2018-04-03T16:02:15.000Z","updated":"2018-04-04T04:53:30.000Z","comments":true,"path":"api/articles/sprouting180404.json","excerpt":"<p></p><p style=\"text-align: center;\">❤</p><p></p>\n<h3 id=\"字符串的比较\"><a href=\"#字符串的比较\" class=\"headerlink\" title=\"字符串的比较\"></a>字符串的比较</h3><ul>\n<li><p>compareTo() 和 compareToIgnoreCase()  </p>\n<ol>\n<li>两个字符数组依次从前开始比较，如果对象位置出现字符不同则返回两个字符的编码之差，后面的字符不再比较；</li>\n<li>如果两个字符数组的长度不一样，并且较短的数组和较长数组所有对应位置的字符都相同，则返回两个数组的长度之差。</li>\n</ol>\n</li>\n<li><p>“==”  </p>\n<ol>\n<li>利用“==”进行比较，如果比较的是基本类型，由于自动拆装箱的机制的存在，故能够直接比较两个值的大小。如:<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;</span><br><span class=\"line\">Integer j = <span class=\"number\">2</span>;</span><br><span class=\"line\">System.out.println(i==j);  <span class=\"comment\">//返回true</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>","keywords":null,"cover":null,"content":null,"text":"❤字符串的比较compareTo() 和 compareToIgnoreCase()  两个字符数组依次从前开始比较，如果对象位置出现字符不同则返回两个字符的编码之差，后面的字符不再比较；如果两个字符数组的长度不一样，并且较短的数组和较长数组所有对应位置的字符都相同，则返回两个数","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":10,"path":"api/tags/sprouting.json"}]},{"title":"Java注释及文档","slug":"sprouting180402","date":"2018-04-02T10:11:56.000Z","updated":"2018-04-07T10:08:04.000Z","comments":true,"path":"api/articles/sprouting180402.json","excerpt":"<p></p><p style=\"text-align: center;\">❤</p><p></p>\n<h3 id=\"Javadoc工具\"><a href=\"#Javadoc工具\" class=\"headerlink\" title=\"Javadoc工具\"></a>Javadoc工具</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javadoc -d <span class=\"string\">\"说明文档准备放到哪儿\"</span> -doctitle <span class=\"string\">\"给说明文档起个标题\"</span> -author -version YourSourceCode.java</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体说明可以通过-help命令查看</span></span><br><span class=\"line\">javadoc -help</span><br></pre></td></tr></table></figure>\n<h3 id=\"如何去写文档注释\"><a href=\"#如何去写文档注释\" class=\"headerlink\" title=\"如何去写文档注释\"></a>如何去写文档注释</h3><ul>\n<li><a href=\"http://www.cnblogs.com/boring09/p/4274893.html\" target=\"_blank\" rel=\"noopener\">参考李舜阳博客—“如何写Java文档注释”</a></li>\n<li><a href=\"http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html#examples\" target=\"_blank\" rel=\"noopener\">官方英文详细文档</a></li>\n</ul>\n<h3 id=\"文档内注释参数使用说明\"><a href=\"#文档内注释参数使用说明\" class=\"headerlink\" title=\"文档内注释参数使用说明\"></a>文档内注释参数使用说明</h3><ul>\n<li><a href=\"http://www.runoob.com/java/java-documentation.html\" target=\"_blank\" rel=\"noopener\">参考Runoob</a></li>\n</ul>","keywords":null,"cover":null,"content":null,"text":"❤Javadoc工具1<br>2<br>3<br>4<br>javadoc -d \"说明文档准备放到哪儿\" -doctitle \"给说明文档起个标题\" -author -version YourSourceCode.java<br><br>// 具体说明可以通过-help命令查看","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":10,"path":"api/tags/sprouting.json"}]},{"title":"Java3rd.log4j","slug":"sprouting180401","date":"2018-04-01T02:02:52.000Z","updated":"2018-04-04T04:55:47.000Z","comments":true,"path":"api/articles/sprouting180401.json","excerpt":"<p></p><p style=\"text-align: center;\">❤</p><p></p>\n<h3 id=\"What-is-the-log4j\"><a href=\"#What-is-the-log4j\" class=\"headerlink\" title=\"What is the log4j?\"></a>What is the log4j?</h3><h3 id=\"How-to-install\"><a href=\"#How-to-install\" class=\"headerlink\" title=\"How to install?\"></a>How to install?</h3><h3 id=\"How-to-use\"><a href=\"#How-to-use\" class=\"headerlink\" title=\"How to use?\"></a>How to use?</h3><h3 id=\"Config-Means\"><a href=\"#Config-Means\" class=\"headerlink\" title=\"Config Means\"></a>Config Means</h3>","keywords":null,"cover":null,"content":null,"text":"❤What is the log4j?How to install?How to use?Config Means<br>  参考文献：<br>🍀From Clover https://aprilsx.github.io/2018/04/01/sprouting180401/ ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":10,"path":"api/tags/sprouting.json"}]},{"title":"Object:所有类的超类","slug":"sprouting180326","date":"2018-03-26T02:35:36.000Z","updated":"2018-04-04T04:56:43.000Z","comments":true,"path":"api/articles/sprouting180326.json","excerpt":"<p style=\"text-align: center;\">❤</p>\n\n<h3 id=\"eaquals\"><a href=\"#eaquals\" class=\"headerlink\" title=\".eaquals()\"></a>.eaquals()</h3><p>用于检测一个对象是否等于另外一个对象，这个方法将判断两个对象是否具有相同的引用。设计评判标准：</p>\n<ul>\n<li>自反性</li>\n<li>对称性</li>\n<li>传递性</li>\n<li>一致性","keywords":null,"cover":null,"content":null,"text":"❤.eaquals()用于检测一个对象是否等于另外一个对象，这个方法将判断两个对象是否具有相同的引用。设计评判标准：自反性对称性传递性一致性我们判断两个对象是否相等，主要得看这两个对象的状态是否相等。这样一来，我们一般会在类中重写equals()这个方法，以此来比较状态的一致性。","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":10,"path":"api/tags/sprouting.json"}]},{"title":"设计技巧","slug":"sprouting180325","date":"2018-03-25T03:32:48.000Z","updated":"2018-04-04T04:56:55.000Z","comments":true,"path":"api/articles/sprouting180325.json","excerpt":"<p style=\"text-align: center;\">❤</p>\n\n<p><img src=\"/images/sprouting180325_1.png\" alt=\"\"></p>\n<h2 id=\"类的设计技巧\"><a href=\"#类的设计技巧\" class=\"headerlink\" title=\"类的设计技巧\"></a>类的设计技巧</h2><ul>\n<li>一定要保证数据私有<ul>\n<li>这是最重要的；绝对不要破坏封装性。有时候，需要编写一个访问器方法或更改器方法，但是最好还是保持实例域的私有性。很多惨痛的经验告诉我们，数据的表示形式很可能会改变，但它们的使用方式却不会经常发生变化。当数据保持私有时，它们的表示形式的变化不会对类的使用者产生影响，即使出现bug也易于检测。","keywords":null,"cover":"/images/sprouting180325_1.png","content":null,"text":"❤ [Figure] 🍀From Clover https://aprilsx.github.io/2018/03/25/sprouting180325/ ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":10,"path":"api/tags/sprouting.json"}]},{"title":"一些关于Java要记住的话","slug":"sprouting180319b","date":"2018-03-19T08:44:36.000Z","updated":"2018-04-04T04:58:44.000Z","comments":true,"path":"api/articles/sprouting180319b.json","excerpt":"<p style=\"text-align: center;\">❤</p>\n\n<ul>\n<li><b>Data</b><ol>\n<li>类名用大驼峰，属性用小驼峰（对于java来说，大小写非常重要）</li>\n<li>源代码的文件名必须与公共类的名字相同，并用.java作为扩展名</li>\n<li>每个java应用程序必须有一个main函数","keywords":null,"cover":"/images/sprouting180319b_1.png","content":null,"text":"❤Data类名用大驼峰，属性用小驼峰（对于java来说，大小写非常重要）源代码的文件名必须与公共类的名字相同，并用.java作为扩展名每个java应用程序必须有一个main函数   每个句子必须以分号结束不要担心你注释的代码会膨胀你的可执行代码Java是一种强类型语言，记住数据类","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":10,"path":"api/tags/sprouting.json"}]},{"title":"英文录","slug":"sprouting180319","date":"2018-03-19T03:05:06.000Z","updated":"2018-04-04T07:03:42.000Z","comments":true,"path":"api/articles/sprouting180319.json","excerpt":"<p style=\"text-align: center;\">❤</p>\n\n<blockquote>\n<ul>\n<li><h3 id=\"Eden\"><a href=\"#Eden\" class=\"headerlink\" title=\"Eden\"></a>Eden</h3><h5 id=\"伊甸园；堆内存中新生代分为Eden-Suvivor\"><a href=\"#伊甸园；堆内存中新生代分为Eden-Suvivor\" class=\"headerlink\" title=\"伊甸园；堆内存中新生代分为Eden,Suvivor\"></a>伊甸园；堆内存中新生代分为Eden,Suvivor</h5><p>  Eden space is where objects are created. Life for them is all happy but eventually they’re chased out by a cherub into the wilderness of the young and later the old generation.</p>\n<p>  They are never allowed back in Eden space, they have to stay in the rough world of continuous tenuring until the Grim Collector comes for them.</p>\n<p>  However, unlike the original Eden, it is possible to die there. Well, I guess all metaphors break down under closer scrutiny.</p>","keywords":null,"cover":null,"content":null,"text":"❤Eden伊甸园；堆内存中新生代分为Eden,Suvivor  Eden space is where objects are created. Life for them is all happy but eventually they’re chased out by a c","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":10,"path":"api/tags/sprouting.json"}]},{"title":"读我","slug":"me180316","date":"2018-03-16T06:38:24.000Z","updated":"2018-03-20T15:40:14.000Z","comments":true,"path":"api/articles/me180316.json","excerpt":"<p style=\"text-align: center;\">❤</p>\n\n<h1 id=\"歌手与歌\"><a href=\"#歌手与歌\" class=\"headerlink\" title=\"歌手与歌\"></a>歌手与歌</h1><blockquote>\n<dl><br>  <dt><b>叶炫清</b> - 从前慢</dt><br>  <dd>“记得早些少年时，大家诚诚恳恳，说一句是一句”</dd><br>  <img src=\"/images/me180316_1.jpeg\" alt=\"\"><br>","keywords":null,"cover":"/images/me180316_1.jpeg","content":null,"text":"❤歌手与歌<br>  叶炫清 - 从前慢<br>  “记得早些少年时，大家诚诚恳恳，说一句是一句”<br>   [Figure] 🍀From Clover https://aprilsx.github.io/2018/03/16/me180316/ ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"me","slug":"me","count":1,"path":"api/tags/me.json"}]}]}