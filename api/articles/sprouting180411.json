{"title":"Java.接口","slug":"sprouting180411","date":"2018-04-11T12:12:24.000Z","updated":"2018-04-13T01:45:01.000Z","comments":true,"path":"api/articles/sprouting180411.json","photos":[],"link":"","excerpt":"❤<br><br>接口技术<br>接口技术是什么？接口技术主要用来描述类具有什么功能，而并不给出每个功能的具体实现。其具体功能的实现，应该交给遵从接口描述的类。一个类可以实现多个接口。接口中声明的方法默认使用的是public修饰符，也必须是public，这个很容易理解，因为你写接口就是让别人去实现的，你要是私有了，还有什么用！","covers":null,"content":"<p></p><p style=\"text-align: center;\">❤</p><br><br><p></p>\n<h1 id=\"接口技术\"><a href=\"#接口技术\" class=\"headerlink\" title=\"接口技术\"></a>接口技术</h1><p><br></p>\n<h3 id=\"接口技术是什么？\"><a href=\"#接口技术是什么？\" class=\"headerlink\" title=\"接口技术是什么？\"></a>接口技术是什么？</h3><ul>\n<li>接口技术主要用来描述类具有什么功能，而并不给出每个功能的具体实现。其具体功能的实现，应该交给遵从接口描述的类。一个类可以实现多个接口。接口中声明的方法默认使用的是public修饰符，也必须是public，这个很容易理解，因为你写接口就是让别人去实现的，你要是私有了，还有什么用！</li>\n</ul>\n<a id=\"more\"></a>\n<p><br></p>\n<h3 id=\"常见的接口技术\"><a href=\"#常见的接口技术\" class=\"headerlink\" title=\"常见的接口技术\"></a>常见的接口技术</h3><ul>\n<li><p>Comparable<br>  Arrays类中的sort方法承诺可以对对象数组进行排序，当对象所属的类必须实现Comparable接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们来定义一个Student类，实现Comparable方法使Student具有按成绩进行排序的功能</span></span><br><span class=\"line\"><span class=\"comment\">// Comparable后面有个&lt;Student&gt;，这是范型应用的小技巧，免去了对参数进行类型转换</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Student</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> grade;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Student otherStudent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Integer.compare(<span class=\"keyword\">this</span>.grade, otherStudent.grade);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(<span class=\"keyword\">int</span> grade)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO Auto-generated constructor stub</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.grade = grade;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面来看看结果，结果在注释里。</span></span><br><span class=\"line\"><span class=\"comment\">// 可以看到，Student通过实现Comparable接口实现了按我们想要的排序方法进行了排序。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Playground</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Student a = <span class=\"keyword\">new</span> Student(<span class=\"number\">96</span>);</span><br><span class=\"line\">        Student b = <span class=\"keyword\">new</span> Student(<span class=\"number\">62</span>);</span><br><span class=\"line\">        Student[] stuList = &#123;a,b&#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 排名前，打印结果如下：</span></span><br><span class=\"line\">        <span class=\"comment\">// [com.learn.aprilsx.Student@7a46a697, com.learn.aprilsx.Student@5f205aa]</span></span><br><span class=\"line\">        System.out.println(Arrays.toString(stuList));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 调用Arrays.sort()进行排序</span></span><br><span class=\"line\">        Arrays.sort(stuList);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 排名后，打印结果如下：</span></span><br><span class=\"line\">        <span class=\"comment\">// [com.learn.runoob.Student@5f205aa, com.learn.runoob.Student@7a46a697]</span></span><br><span class=\"line\">        System.out.println(Arrays.toString(stuList));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Comparator<br>  如果说，我们想要有多种排序方式可以选择，或者我们想要自定义自己的排序方式。因为Comparable的实现只是提供了一种效果，我们想要多种。这时候我们就可以创建一个类，并通过实现Compartor接口让它升级为一个比较器。配合<code>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)</code>我们就可以实现以我们想要的方式进行排序了。<br>  这是一个关于String类中不包含的一种排序方式的案例。（String.compareTo默认是按字典顺序进行排序的，这个字典是真的字典，新华字典的字典）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 定义一个比较器，来实现我们想要的按字符串长度进行排序的效果</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LengthComparator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String str1, String str2)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> str1.length()-str2.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 然后在main中进行测试</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    String[] places = &#123;<span class=\"string\">\"Yuncheng\"</span>,<span class=\"string\">\"Xian\"</span>,<span class=\"string\">\"Tianjing\"</span>,<span class=\"string\">\"Shanghai\"</span>&#125;;</span><br><span class=\"line\">    System.out.println(Arrays.toString(places));</span><br><span class=\"line\">    Arrays.sort(places,<span class=\"keyword\">new</span> LengthComparator());</span><br><span class=\"line\">    System.out.println(Arrays.toString(places));   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  <b>彩蛋: 使用lambda表达式可以更容易地实现Comparator</b></p>\n</li>\n</ul>\n<p><br></p>\n<ul>\n<li>Cloneable<br>  Cloneable是非常重要的内置接口。如果某个类实现了这个接口，那么它便具有了拷贝能力。对象拷贝的设计是很重要的，必须掌握。<br>  克隆涉及深浅拷贝的相关知识。对象的克隆，如果从根本意义上实现克隆，必须实现深拷贝。这也正是Cloneable接口的用处。<br>  编写Cloneable的实现之前，先需要确定以下几点：<pre><code>1. 默认的clone方法是否满足要求\n2. 是否可以在可变的子对象上调用clone来修补默认的clone方法\n3. 是否不该使用clone\n</code></pre>  如果决定使用Cloneable实现对象的拷贝，那么类必须：<pre><code>1. 实现Cloneable接口\n2. 重新定义clone方法，并指定public访问修饰符\n</code></pre><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">implements</span> <span class=\"title\">Powered</span>,<span class=\"title\">Cloneable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实例域部分，这里用了Date</span></span><br><span class=\"line\">    <span class=\"comment\">// 因为Date和LocalDate的内存分配是有差别的,所以需要对Date进行clone</span></span><br><span class=\"line\">    <span class=\"comment\">// 现在都建议使用LocalDate进行日期的创建</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> salary;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> java.util.Date hireDay;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">B</span><span class=\"params\">(String name,<span class=\"keyword\">double</span> salary)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.salary = salary;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hireDay = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// call Object.clone()</span></span><br><span class=\"line\">        B cloned = (B) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// clone mutable fields</span></span><br><span class=\"line\">        <span class=\"comment\">// 对可变的域进行拷贝，这样拷贝出来的对象状态的改变将不影响源对象</span></span><br><span class=\"line\">        cloned.hireDay = (Date) hireDay.clone();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 返回我们创建的cloned对象，实现克隆</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cloned;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"接口的特性\"><a href=\"#接口的特性\" class=\"headerlink\" title=\"接口的特性\"></a>接口的特性</h3><ul>\n<li>接口可以被扩展</li>\n<li>接口中虽然不能包含实例域或静态方法，但却可以包含常量</li>\n<li>接口中可以实现默认方法的实现，记得用default进行标记哦。<b>默认方法的一个重要用法是实现“接口演化”（interface evolution）</b><ul>\n<li>什么是接口演化？<br>  假如有个类A实现了一个接口InterfaceA，用了不知道几年了，InterfaceA老了，我们现在需要给这个接口里增加一个方法，methodZ。然后你会发现A类编译不过去了，原因很简单，就是因为A必须实现所有InterfaceA里的方法，你现在加了一个新的进去，当然编译出现了问题。那如果接口里这个方法有默认实现，那么在编译的时候，直接找接口里的方法就可以了，这就解决了“源代码兼容（source compatible）”问题。</li>\n<li>沿用接口演化的例子，如果A类的超类SuperA中也有一个methodZ咋办？<br>  爸爸最大！这就是<b>超类优先原则</b>，不用想，听爸爸的就对了。(所以千万不要让接口中的默认方法重新定义Object类中的某个方法，因为爸爸最大！)</li>\n<li>那如果现在A类又实现了个InterfaceB，它也有一个mehodZ咋办？<br>  那你需要在A类里重写这个方法了！当然你是可以选择的，重写完methodZ之后通过super就能实现选择了。比如我选InterfaceB的，我就<code>return InterfaceB.super.methodZ();</code></li>\n</ul>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"接口与抽象类引发的疑问\"><a href=\"#接口与抽象类引发的疑问\" class=\"headerlink\" title=\"接口与抽象类引发的疑问\"></a>接口与抽象类引发的疑问</h3><ul>\n<li>我们很容易会有这样的疑问，一个全是抽象方法的抽象类和一个接口有啥子区别呢？<br>  一个重大的区别就是，在Java中，<b>类是不支持多继承的！</b>类要扩展只能扩展一个，它远不如接口，可以实现多个。</li>\n</ul>\n<p><br></p>\n<h3 id=\"接口与回调\"><a href=\"#接口与回调\" class=\"headerlink\" title=\"接口与回调\"></a>接口与回调</h3><ul>\n<li>定时器主动轮询是一个经典的用例，让类去实现定时器提供的接口，这样就可以在某个特定时间发生时采取相应的动作了！一起来看代码：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 首先创建TimerPrinter类，</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现java.swing.Timer的ActionListener接口。</span></span><br><span class=\"line\"><span class=\"comment\"> * 这样，在创建Timer(1000,TimerPrinter的实例)后，就能每隔固定时间间隔来调用actionPerformed这个方法了</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimerPrinter</span> <span class=\"keyword\">implements</span> <span class=\"title\">ActionListener</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">actionPerformed</span><span class=\"params\">(ActionEvent event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"定时器每隔一段时间调用了这个方法: \"</span>+ <span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">        Toolkit.getDefaultToolkit().beep();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 然后在main中实现定时器的轮询测试</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ActionListener listener = <span class=\"keyword\">new</span> TimerPrinter();</span><br><span class=\"line\">        Timer t = <span class=\"keyword\">new</span> Timer(<span class=\"number\">1000</span>,listener);</span><br><span class=\"line\">        t.start();</span><br><span class=\"line\">        JOptionPane.showMessageDialog(<span class=\"keyword\">null</span>, <span class=\"string\">\"Quit program?\"</span>);</span><br><span class=\"line\">        System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>  参考文献：<br>  [ 1 ] Java核心技术I p212-263<br><br></p>\n</blockquote>\n<p>🍀From Clover <a href=\"https://aprilsx.github.io/2018/04/11/sprouting180411/\">https://aprilsx.github.io/2018/04/11/sprouting180411/</a> </p>\n","categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]}