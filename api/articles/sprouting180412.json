{"title":"Java.lambda","slug":"sprouting180412","date":"2018-04-12T06:27:09.000Z","updated":"2018-04-13T01:35:02.000Z","comments":true,"path":"api/articles/sprouting180412.json","photos":[],"link":"","excerpt":"❤<br><br>lambda表达式数学中，带参数变量的表达式被称为lambda表达式。这背后有一小段故事。<br>为什么引入lambda表达式？道理具简单，为了代码简洁，可读性高。lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。注意“以后”两个字，它意味着你在想用它的时候，在调它。这岂不是很方便么！了解Objective-C的一定会第一时间想到，这不就是block吗？是的，确实是一个意思。","covers":null,"content":"<p></p><p style=\"text-align: center;\">❤</p><br><br><p></p>\n<h1 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a>lambda表达式</h1><p><a href=\"https://www.zhihu.com/question/27448188\" target=\"_blank\" rel=\"noopener\">数学中，带参数变量的表达式被称为lambda表达式。这背后有一小段故事。</a></p>\n<p><br></p>\n<h3 id=\"为什么引入lambda表达式？\"><a href=\"#为什么引入lambda表达式？\" class=\"headerlink\" title=\"为什么引入lambda表达式？\"></a>为什么引入lambda表达式？</h3><ul>\n<li>道理具简单，为了代码简洁，可读性高。lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。注意“以后”两个字，它意味着你在想用它的时候，在调它。这岂不是很方便么！了解Objective-C的一定会第一时间想到，这不就是block吗？是的，确实是一个意思。</li>\n</ul>\n<a id=\"more\"></a>\n<p><br></p>\n<h3 id=\"lambda表达式的语法\"><a href=\"#lambda表达式的语法\" class=\"headerlink\" title=\"lambda表达式的语法\"></a>lambda表达式的语法</h3><ul>\n<li><code>( )-&gt;{ }</code>就是这个样子的一个东西，Java8让很多程序猿们激动不已。<b>用lambda要谨记传入代码的变量规范。</b>在下面实践中，我们来一步一步熟悉。</li>\n</ul>\n<p><br></p>\n<h3 id=\"用lambda改写《Java-接口》一篇中的两个案例\"><a href=\"#用lambda改写《Java-接口》一篇中的两个案例\" class=\"headerlink\" title=\"用lambda改写《Java.接口》一篇中的两个案例\"></a>用lambda改写《Java.接口》一篇中的两个案例</h3><ul>\n<li><p>用lambda表达式改写lengthComparator比较器用例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 用lambda表达式改写lengthComparator比较器用例</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    String[] places = &#123;<span class=\"string\">\"Yuncheng\"</span>,<span class=\"string\">\"Xian\"</span>,<span class=\"string\">\"Tianjing\"</span>,<span class=\"string\">\"Shanghai\"</span>&#125;;</span><br><span class=\"line\">    System.out.println(Arrays.toString(places));</span><br><span class=\"line\">    Arrays.sort(places,(first,second)-&gt;first.length()-second.length());</span><br><span class=\"line\">    System.out.println(Arrays.toString(places));   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用lambda表达式改写Timer轮询用例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 用lambda表达式改写lengthComparator比较器用例</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Timer t = <span class=\"keyword\">new</span> Timer(<span class=\"number\">1000</span>, event-&gt;System.out.println(<span class=\"string\">\"The time is:\"</span>+<span class=\"keyword\">new</span> Date()));</span><br><span class=\"line\">    t.start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置用户中断干涉</span></span><br><span class=\"line\">    JOptionPane.showMessageDialog(<span class=\"keyword\">null</span>, <span class=\"string\">\"停止打印？\"</span>);</span><br><span class=\"line\">    System.exit(<span class=\"number\">0</span>);   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"函数式接口（functional-interface）\"><a href=\"#函数式接口（functional-interface）\" class=\"headerlink\" title=\"函数式接口（functional interface）\"></a>函数式接口（functional interface）</h3><p>上面用lambda实现的ActionListener或Comparator貌似很难理解，这是因为Java库已经为我们封装了这个代码块接口（比如我们可以看到源码里Comparator类最前头标记有@FunctionalInterface），lambda表达式与这些接口是兼容的。我们只是使用了它而已。</p>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/dd864140130/article/details/50521125\" target=\"_blank\" rel=\"noopener\">什么是函数式接口？</a><br>  函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。点进题目的链接，“江湖人称小白哥”给了我们一个很好的例子。</p>\n</li>\n<li><p>了解lambda形式的函数式接口<br>  对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式来替代去创建这个对象。直接去关注具体实现，而忽略对这个接口类的对象的创建。这种接口被称为函数式接口。</p>\n</li>\n<li><p>案例分析</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Arrays.sort(places,(first,second)-&gt;first.length()-second.length());</span><br></pre></td></tr></table></figure>\n<p>  以上面这段代码为例。Arrays.sort()方法里有两个参数，第一个是待排序的数组，第二个是Comparator类的一个实例对象。Comparator就是只有一个方法的接口，因此我们可以提供一个lambda表达式，而不用去new一个Comparator，像这样<code>new Comparator()</code>。<br>  在底层，Arrays.sort方法会接收实现了Comparator<string>的某个类的对象。在这个对象上调用compare方法会执行这个lambda表达式的体。</string></p>\n</li>\n<li><p>理解lambda表达式可以转换为接口<br>  实际上，在Java中，对lambda表达式所能做的也只是能转换为函数式接口。我们要谨记的是，想要用lambda表达式做某些处理，必须为它建立一个特定的函数式接口！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 一个超级棒的例子，关于java.util.function中的Predicate接口</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    ArrayList alist = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">    alist.add(<span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">    alist.add(<span class=\"string\">\"B\"</span>);</span><br><span class=\"line\">    alist.add(<span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">    alist.add(<span class=\"string\">\"C\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 原数组展示</span></span><br><span class=\"line\">    String[] strarr = (String[]) alist.toArray(<span class=\"keyword\">new</span> String[alist.size()]);</span><br><span class=\"line\">    System.out.println(Arrays.toString(strarr));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 移除数组历表中“A”</span></span><br><span class=\"line\">    alist.removeIf(e-&gt;e.equals(<span class=\"string\">\"A\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 处理后数组的展示</span></span><br><span class=\"line\">    String[] strbrr = (String[]) alist.toArray(<span class=\"keyword\">new</span> String[alist.size()]);</span><br><span class=\"line\">    System.out.println(Arrays.toString(strbrr));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h3><p>有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。这时便可以使用方法引用，用两个冒号来表示引用“::”<br><b>“::”操作符分隔方法名与对象或类名</b></p>\n<ul>\n<li><p>例子1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Timer t = <span class=\"keyword\">new</span> Timer(<span class=\"number\">1000</span>, System.out::println);</span><br><span class=\"line\"><span class=\"comment\">// 等价于Timer t = new Timer(1000, x-&gt;(System.out.println(x));</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例子2</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Arrays.sort(strings, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>“::”的操作符用法主要有3种情况</p>\n<ul>\n<li>object::instanceMethod</li>\n<li>Class::staticMethod</li>\n<li>Class::instanceMethod</li>\n</ul>\n</li>\n</ul>\n<p>前2种情况中，方法引用等价于提供方法参数的lambda表达式。如，Math::pow等价于(x,y)-&gt;Math.pow(x,y)<br>对于第3种情况，设计函数式接口中的第1个参数会成为方法的目标。如，Stirng::compareToIgnoreCase等价于(x,y)-&gt;x.compareToIgnoreCase(y)</p>\n<p><br></p>\n<h3 id=\"构造器引用\"><a href=\"#构造器引用\" class=\"headerlink\" title=\"构造器引用\"></a>构造器引用</h3><p>构造器引用与方法引用很类似，只不过在使用时方法名为new。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; names = ...;</span><br><span class=\"line\">Stream&lt;Person&gt; stream = names.stream().map(Person::<span class=\"keyword\">new</span>);</span><br><span class=\"line\">List&lt;Person&gt; people = stream.collect(Collectors.toList());</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h3><ul>\n<li><p>下面看一个错误的例子，从这个例子能够引发对lambda表达式中变量作用域的思考</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">repeatMessage</span><span class=\"params\">(String text, <span class=\"keyword\">int</span> delay)</span></span>&#123;</span><br><span class=\"line\">    ActionListener listener = event -&gt; &#123;</span><br><span class=\"line\">        System.out.println(text);</span><br><span class=\"line\">        Toolkit.getDefaultToolkit().beep();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Timer(delay, listener).start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用这个方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    repeatMessage(<span class=\"string\">\"Hello\"</span>,<span class=\"number\">1000</span>); <span class=\"comment\">// 结果是每1秒打印一次Hello</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>看起来似乎没有错误的例子错哪了？<br>  错就错在了lambda表达式中对外部变量text的进行了引用。<a href=\"https://blog.csdn.net/balternotz/article/details/60465335\" target=\"_blank\" rel=\"noopener\">具体的原因，我觉得BalterNotz的这个博客写的不错，可以参考看下。</a></p>\n</li>\n<li><p>记住一条规则<br>  lambda表达式中捕获的变量必须实际上是最终变量(effectively final)，实际上的最终变量指的是，这个变量初始化之后就不会再为它赋新值。另一点，在lambda表达式的数据结构必须存储自由变量的值。</p>\n</li>\n</ul>\n<p><b>彩蛋:关于变量作用域这点，内部类便体现出它的优越性！</b></p>\n<p><br></p>\n<h3 id=\"自己写一个lambda\"><a href=\"#自己写一个lambda\" class=\"headerlink\" title=\"自己写一个lambda\"></a>自己写一个lambda</h3><ul>\n<li>主要其实就两步:<ol>\n<li>编写一个函数式接口</li>\n<li>在适当的地方使用lambda表达式，替代使用时生成函数式接口的对象，以此完成逻辑事务的处理<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建一个函数式接口</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">StringChanger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">stringChange</span><span class=\"params\">(String str)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  我把创建的函数式接口应用在一个自定义类的方法中，</span></span><br><span class=\"line\"><span class=\"comment\"> *  这样在使用时便可以通过传入lambda表达式来替代changer对象，最终完成逻辑任务</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">learnWring</span><span class=\"params\">(String oriWrite, StringChanger changer)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"原字符串是:\"</span>+oriWrite);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"处理后的字符串是:\"</span>+changer.stringChange(oriWrite));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Child.learnWring(<span class=\"string\">\"nihao\"</span>, (param)-&gt;&#123;</span><br><span class=\"line\">        String nowStr = param.toUpperCase();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nowStr;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"需要烂熟于心的函数式接口\"><a href=\"#需要烂熟于心的函数式接口\" class=\"headerlink\" title=\"需要烂熟于心的函数式接口\"></a>需要烂熟于心的函数式接口</h3><ul>\n<li>在java.util.function包中所提供的都是函数式接口，下面的接口均来自其中。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数式接口</th>\n<th style=\"text-align:center\">抽象方法名</th>\n<th style=\"text-align:center\">映射记忆</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Runnable</td>\n<td style=\"text-align:center\">run( )</td>\n<td style=\"text-align:center\">( )-&gt;{ }</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Supplier<t></t></td>\n<td style=\"text-align:center\">get( )</td>\n<td style=\"text-align:center\">( )-&gt;{ return T }</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Consumer<t></t></td>\n<td style=\"text-align:center\">accept( )</td>\n<td style=\"text-align:center\">( T )-&gt;{ }</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BiConsumer&lt;T,U&gt;</td>\n<td style=\"text-align:center\">accept( )</td>\n<td style=\"text-align:center\">( T, U )-&gt;{ }</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Function&lt;T,R</td>\n<td style=\"text-align:center\">apply( )</td>\n<td style=\"text-align:center\">( T )-&gt;{ return R }</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BiFunction&lt;T,U,R&gt;</td>\n<td style=\"text-align:center\">apply( )</td>\n<td style=\"text-align:center\">( T, U )-&gt;{ return R }</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">UnaryOperator<t></t></td>\n<td style=\"text-align:center\">apply( )</td>\n<td style=\"text-align:center\">( T )-&gt;{ return T }</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BinaryOperator&lt;T,T&gt;</td>\n<td style=\"text-align:center\">apply( )</td>\n<td style=\"text-align:center\">( T, T )-&gt;{ return T }</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Predicate<t></t></td>\n<td style=\"text-align:center\">test( )</td>\n<td style=\"text-align:center\">( T )-&gt;{ return boolean }</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BiPredicate&lt;T,U&gt;</td>\n<td style=\"text-align:center\">test( )</td>\n<td style=\"text-align:center\">( T )-&gt;{ return boolean }</td>\n</tr>\n</tbody>\n</table>\n<p><br></p>\n<blockquote>\n<p>  参考文献：<br>  [ 1 ] Java核心技术I p232-263<br>  [ 2 ] <a href=\"https://www.zhihu.com/question/27448188\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/27448188</a><br>  [ 3 ] <a href=\"https://blog.csdn.net/dd864140130/article/details/50521125\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/dd864140130/article/details/50521125</a><br>  [ 4 ] <a href=\"https://blog.csdn.net/balternotz/article/details/60465335\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/balternotz/article/details/60465335</a><br><br></p>\n</blockquote>\n<p>🍀From Clover <a href=\"https://aprilsx.github.io/2018/04/12/sprouting180412/\">https://aprilsx.github.io/2018/04/12/sprouting180412/</a> </p>\n","categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":16,"path":"api/tags/sprouting.json"}]}