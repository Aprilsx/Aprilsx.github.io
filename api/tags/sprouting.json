{"name":"sprouting","slug":"sprouting","count":5,"postlist":[{"title":"英文录","slug":"sprouting180319","date":"2018-03-19T03:05:06.000Z","updated":"2018-03-25T10:37:08.000Z","comments":true,"path":"api/articles/sprouting180319.json","excerpt":"","keywords":null,"cover":null,"content":"<p style=\"text-align: center;\">❤</p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">缩写</th>\n<th style=\"text-align:left\">源词</th>\n<th style=\"text-align:left\">译</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">concat,cat</td>\n<td style=\"text-align:left\">concatenate</td>\n<td style=\"text-align:left\">连接，串联</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ls</td>\n<td style=\"text-align:left\">list</td>\n<td style=\"text-align:left\">列出文件列表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mkdir</td>\n<td style=\"text-align:left\">make directories</td>\n<td style=\"text-align:left\">创建路径</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cd</td>\n<td style=\"text-align:left\">change directory</td>\n<td style=\"text-align:left\">进入某路径下</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">.</td>\n<td style=\"text-align:left\">the current directory</td>\n<td style=\"text-align:left\">当前目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">..</td>\n<td style=\"text-align:left\">the parent directory</td>\n<td style=\"text-align:left\">上级目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">pwd</td>\n<td style=\"text-align:left\">print work directory</td>\n<td style=\"text-align:left\">显示当前目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">~</td>\n<td style=\"text-align:left\">your home directory</td>\n<td style=\"text-align:left\">根目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cp</td>\n<td style=\"text-align:left\">copy</td>\n<td style=\"text-align:left\">复制</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mv</td>\n<td style=\"text-align:left\">move</td>\n<td style=\"text-align:left\">移动，剪切</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">rm</td>\n<td style=\"text-align:left\">remove</td>\n<td style=\"text-align:left\">删除</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">rmdir</td>\n<td style=\"text-align:left\">remove directory</td>\n<td style=\"text-align:left\">删除路径，其实就是删除空文件夹</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">clear,cl</td>\n<td style=\"text-align:left\">clear screen</td>\n<td style=\"text-align:left\">清屏</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">grep</td>\n<td style=\"text-align:left\">don’t f*ck ask why it is called ‘grep’</td>\n<td style=\"text-align:left\">老子也不知道为啥</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wc</td>\n<td style=\"text-align:left\">word count</td>\n<td style=\"text-align:left\">统计文件基本信息，文本有几行，文件有多大，叫啥名…</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">&gt;</td>\n<td style=\"text-align:left\">redirection</td>\n<td style=\"text-align:left\">重定向，新建文件也行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">&gt;&gt;</td>\n<td style=\"text-align:left\">appending to a file</td>\n<td style=\"text-align:left\">向文件中追加内容</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chmod</td>\n<td style=\"text-align:left\">change a file mode</td>\n<td style=\"text-align:left\">更改文件访问权限，一般就read,write,excute</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ps</td>\n<td style=\"text-align:left\">process status</td>\n<td style=\"text-align:left\">查看进程状态</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">kill</td>\n<td style=\"text-align:left\">terminal or signal a process</td>\n<td style=\"text-align:left\">杀死进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">man</td>\n<td style=\"text-align:left\">manual</td>\n<td style=\"text-align:left\">手册</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">strip</td>\n<td style=\"text-align:left\">stripping unnecessary code</td>\n<td style=\"text-align:left\">压缩代码，把对用户而言没必要的代码删除</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">fork</td>\n<td style=\"text-align:left\">分叉</td>\n<td style=\"text-align:left\">(especially of a road or other route) divide into two parts: “the place where the road forks” synonyms: split, branch (off), divide, subdivide, separate, … more</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">construct</td>\n<td style=\"text-align:left\">构造</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">instance field</td>\n<td style=\"text-align:left\">实例域</td>\n<td style=\"text-align:left\">比如一个对象中的数据，这些实例域值能够代表该对象的状态</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">encapsulation</td>\n<td style=\"text-align:left\">封装</td>\n<td style=\"text-align:left\">有时称为数据隐藏</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">inheritance</td>\n<td style=\"text-align:left\">继承</td>\n<td style=\"text-align:left\">所有的类都源自于一个神通广大的超类，Object</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">“uses-a”</td>\n<td style=\"text-align:left\">依赖</td>\n<td style=\"text-align:left\">dependence，如果一个类的方法操作另一个类的对象，那么它们之间就存在依赖关系</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">“has-a”</td>\n<td style=\"text-align:left\">聚合</td>\n<td style=\"text-align:left\">aggregation</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">UML</td>\n<td style=\"text-align:left\">Unified Modeling Language</td>\n<td style=\"text-align:left\">统一建模语言</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">epoch</td>\n<td style=\"text-align:left\">纪元</td>\n<td style=\"text-align:left\">时间基准</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">UTC</td>\n<td style=\"text-align:left\">Coordinated Universal Time</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GMT</td>\n<td style=\"text-align:left\">Greenwich Mean Time</td>\n<td style=\"text-align:left\">格林威时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mutator method</td>\n<td style=\"text-align:left\">更改器方法</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">accessor method</td>\n<td style=\"text-align:left\">访问器方法</td>\n<td style=\"text-align:left\">典型的比如，只返回实例域值的域访问器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">workhorse class</td>\n<td style=\"text-align:left\">主力类</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">implicit</td>\n<td style=\"text-align:left\">隐式参数</td>\n<td style=\"text-align:left\">有人也把隐式参数称为方法调用的目标，关键字<code>this</code>就是它</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">explicit</td>\n<td style=\"text-align:left\">显示参数</td>\n<td style=\"text-align:left\">即向方法中传入的参数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">primitive</td>\n<td style=\"text-align:left\">基本</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">immutable</td>\n<td style=\"text-align:left\">不可变</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">package sealing</td>\n<td style=\"text-align:left\">包密封机制</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Overloading resolution</td>\n<td style=\"text-align:left\">重载解析</td>\n<td style=\"text-align:left\">重载指的是存在多个构造器，重载解析指的是编译器找到相应的构造器的过程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">inheritance</td>\n<td style=\"text-align:left\">继承</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">reflection</td>\n<td style=\"text-align:left\">反射</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">polymorphism</td>\n<td style=\"text-align:left\">多态</td>\n<td style=\"text-align:left\">一个对象变量可以指示多种实际类型的现象被称为多态</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">dynamic binding</td>\n<td style=\"text-align:left\">动态绑定</td>\n<td style=\"text-align:left\">在运行时能够自动地选择调用哪个方法的现象称为动态绑定</td>\n</tr>\n</tbody>\n</table>\n<p><br></p>\n<blockquote>\n<p>  参考文献：<br>  [ 1 ]   <a href=\"https://stackoverflow.com/questions/10493428/what-does-the-word-concat-actually-or-originally-mean\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/10493428/what-does-the-word-concat-actually-or-originally-mean</a><br>  [ 2 ]   <a href=\"http://www.ee.surrey.ac.uk/Teaching/Unix/\" target=\"_blank\" rel=\"noopener\">http://www.ee.surrey.ac.uk/Teaching/Unix/</a></p>\n</blockquote>\n<p>🍀From Clover <a href=\"https://aprilsx.github.io/2018/03/19/sprouting180319/\">https://aprilsx.github.io/2018/03/19/sprouting180319/</a> </p>\n","text":"❤缩写源词译concat,catconcatenate连接，串联lslist列出文件列表mkdirmake directories创建路径cdchange directory进入某路径下.the current directory当前目录..the parent director","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":5,"path":"api/tags/sprouting.json"}]},{"title":"Java中main函数","slug":"sprouting180315","date":"2018-03-15T09:58:29.000Z","updated":"2018-03-25T03:49:45.000Z","comments":true,"path":"api/articles/sprouting180315.json","excerpt":"<p style=\"text-align: center;\">❤</p>  \n\n<p>上手第一个Java程序，照着课本例子抄的，全程手写，结果终了执行的时候出了问题。<br></p>\n<ul>\n<li>下面是我写的错误代码：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.trainning.aprilsx;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> april</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Welcome</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        String greeting = <span class=\"string\">\"Welcom to Core Java!\"</span>;</span><br><span class=\"line\">        System.out.println(greeting);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; greeting.length(); i++)</span><br><span class=\"line\">            System.out.print(<span class=\"string\">\"=\"</span>);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>","keywords":null,"cover":"/images/sprouting180319_1.png","content":null,"text":"❤  上手第一个Java程序，照着课本例子抄的，全程手写，结果终了执行的时候出了问题。<br>下面是我写的错误代码：  1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":5,"path":"api/tags/sprouting.json"}]},{"title":"一些关于Java要记住的话","slug":"sprouting180319b","date":"2018-03-19T08:44:36.000Z","updated":"2018-03-25T03:49:22.000Z","comments":true,"path":"api/articles/sprouting180319b.json","excerpt":"<p style=\"text-align: center;\">❤</p>\n\n<ul>\n<li><b>Data</b><ol>\n<li>类名用大驼峰，属性用小驼峰（对于java来说，大小写非常重要）</li>\n<li>源代码的文件名必须与公共类的名字相同，并用.java作为扩展名</li>\n<li>每个java应用程序必须有一个main函数   </li>\n<li>每个句子必须以分号结束</li>\n<li>不要担心你注释的代码会膨胀你的可执行代码</li>\n<li>Java是一种强类型语言，记住数据类型的大小很重要。Java没有任何无符号形式的整型，这是因为Java跨平台的原因，规定了数值类型所占据的字节数量与平台无关</li>\n<li>16进制：0x; 2进制：0b; float：f; double：d（建议不使用8进制，8进制数前缀为0，不好区分;16进制可以表示浮点数，如0.125可表示为0x1.0p-3）</li>\n<li>从Java7以后，数字字面量中能够添加下划线，如1_000等价于1000</li>\n<li>浮点数值不适合用于无法接受舍入误差的金融计算中。如果不允许任何舍入误差情况存在，就应该使用BigDecimal类</li>\n<li>Java有一个能够表示任意精度的算术包，通常称为“大数值”——big number，一个Java对象","keywords":null,"cover":"/images/sprouting180319b_1.png","content":null,"text":"❤Data类名用大驼峰，属性用小驼峰（对于java来说，大小写非常重要）源代码的文件名必须与公共类的名字相同，并用.java作为扩展名每个java应用程序必须有一个main函数   每个句子必须以分号结束不要担心你注释的代码会膨胀你的可执行代码Java是一种强类型语言，记住数据类","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":5,"path":"api/tags/sprouting.json"}]},{"title":"类设计技巧","slug":"sprouting180325","date":"2018-03-25T03:32:48.000Z","updated":"2018-03-25T05:17:14.000Z","comments":true,"path":"api/articles/sprouting180325.json","excerpt":"","keywords":null,"cover":"/images/sprouting180325_1.png","content":"<p style=\"text-align: center;\">❤</p>\n\n<p><img src=\"/images/sprouting180325_1.png\" alt=\"\"></p>\n<h2 id=\"不用记，变成习惯就好\"><a href=\"#不用记，变成习惯就好\" class=\"headerlink\" title=\"不用记，变成习惯就好\"></a>不用记，变成习惯就好</h2><ul>\n<li>一定要保证数据私有<ul>\n<li>这是最重要的；绝对不要破坏封装性。有时候，需要编写一个访问器方法或更改器方法，但是最好还是保持实例域的私有性。很多惨痛的经验告诉我们，数据的表示形式很可能会改变，但它们的使用方式却不会经常发生变化。当数据保持私有时，它们的表示形式的变化不会对类的使用者产生影响，即使出现bug也易于检测。</li>\n</ul>\n</li>\n<li>一定要对数据初始化</li>\n<li>不要在类中使用过多的基本类型<ul>\n<li>如果存在多个属性具有一定联系的情况，最好将这几个属性构建成对象，以方便使用</li>\n</ul>\n</li>\n<li>不是所有的域都需要独立的域访问器和域更改器</li>\n<li>将职责过多的类进行分解</li>\n<li>类名和方法名要能够体现它们的职责</li>\n<li>优先使用不可变的类<ul>\n<li>更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改。其结果是不可预料的。如果类是不可变的，就可以安全地在多个线程间共享其对象</li>\n</ul>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>  参考文献：<br>  [ 1 ] 《Java核心技术 I》- p144<br><br></p>\n</blockquote>\n<p>🍀From Clover <a href=\"https://aprilsx.github.io/2018/03/25/sprouting180325/\">https://aprilsx.github.io/2018/03/25/sprouting180325/</a> </p>\n","text":"❤ [Figure] 🍀From Clover https://aprilsx.github.io/2018/03/25/sprouting180325/ ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":5,"path":"api/tags/sprouting.json"}]},{"title":"Object:所有类的超类","slug":"sprouting180326","date":"2018-03-26T02:35:36.000Z","updated":"2018-03-28T04:52:33.000Z","comments":true,"path":"api/articles/sprouting180326.json","excerpt":"","keywords":null,"cover":null,"content":"<p style=\"text-align: center;\">❤</p>\n\n<h3 id=\"eaquals\"><a href=\"#eaquals\" class=\"headerlink\" title=\".eaquals()\"></a>.eaquals()</h3><p>用于检测一个对象是否等于另外一个对象，这个方法将判断两个对象是否具有相同的引用。设计评判标准：</p>\n<pre><code>+ 自反性\n+ 对称性\n+ 传递性\n+ 一致性\n</code></pre><p>我们判断两个对象是否相等，主要得看这两个对象的状态是否相等。这样一来，我们一般会在类中重写equals()这个方法，以此来比较状态的一致性。<br>模版与注意事项如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">YourClass</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">eaquals</span><span class=\"params\">(Object otherObject)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 判断引用是否相同，如果内存的引用相同，那肯定是相同的</span></span><br><span class=\"line\">        <span class=\"comment\">// a quick test to see if the objects are identical.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == otherObject) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 2. 判断参数是否非空</span></span><br><span class=\"line\">        <span class=\"comment\">// must return false if the explicit parameter is null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (otherObject == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 3. 判断是否为同一类</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里需要看情况处理</span></span><br><span class=\"line\">        <span class=\"comment\">// * 子类能够拥有自己的相等概念，则对称性需求将强制采用getClass进行检测</span></span><br><span class=\"line\">        <span class=\"comment\">// ** 超类决定了相等的概念，那么使用instanceof判断是否是该超类的子类就可以了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getClass() != otherObject.getClass()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 4. 判断被比较的两个对象的状态是否一致</span></span><br><span class=\"line\">        <span class=\"comment\">// now we know 'otherObject' which 'non-null YourClass'</span></span><br><span class=\"line\">        YourClass other = (YourClass) otherObject;</span><br><span class=\"line\">        <span class=\"comment\">// 假设你的对象实例域有：name,salary,hireDay</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> name.eaquals(other.name) &amp;&amp; salary == other.salary &amp;&amp; hireDay.eaquals(other.hireDay);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"hashCode\"><a href=\"#hashCode\" class=\"headerlink\" title=\".hashCode()\"></a>.hashCode()</h3><p>散列码（hash code）是由对象导出的一个整型值，它是没有规律的。<br>需要注意一些类的散列码的值，如StringBuffer类，它没有定义hashCode方法，它的散列码是由Object类的默认hashCode方法导出的对象存储地址。所以虽然内容相同，但生成的hash code却不相同<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringBuilder a = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"Aprilsx\"</span>);</span><br><span class=\"line\">StringBuilder b = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"Aprilsx\"</span>);</span><br><span class=\"line\">a.hashCode != b.hashCode</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\".toString()\"></a>.toString()</h3><p>通常在子类中重写该方法，设计子类的域的描述。<br>随处可见toString()方法的主要原因是：只要对象与一个字符串通过操作符“+”连接起来，java编译就会自动调用toString()方法，以便获得这个对象的字符串描述。</p>\n<p><br></p>\n<blockquote>\n<p>  参考文献：<br>  [ 1 ] 《Java核心技术 I》- p166</p>\n<p><br></p>\n</blockquote>\n<p>🍀From Clover <a href=\"https://aprilsx.github.io/2018/03/26/sprouting180326/\">https://aprilsx.github.io/2018/03/26/sprouting180326/</a> </p>\n","text":"❤.eaquals()用于检测一个对象是否等于另外一个对象，这个方法将判断两个对象是否具有相同的引用。设计评判标准：+ 自反性+ 对称性+ 传递性+ 一致性我们判断两个对象是否相等，主要得看这两个对象的状态是否相等。这样一来，我们一般会在类中重写equals()这个方法，以此来比","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":5,"path":"api/tags/sprouting.json"}]}]}