{"name":"sprouting","slug":"sprouting","count":17,"postlist":[{"title":"Java中main函数","slug":"sprouting180315","date":"2018-03-15T09:58:29.000Z","updated":"2018-03-25T03:49:45.000Z","comments":true,"path":"api/articles/sprouting180315.json","excerpt":"<p style=\"text-align: center;\">❤</p>  \n\n<p>上手第一个Java程序，照着课本例子抄的，全程手写，结果终了执行的时候出了问题。<br></p>\n<ul>\n<li>下面是我写的错误代码：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.trainning.aprilsx;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> april</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Welcome</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        String greeting = <span class=\"string\">\"Welcom to Core Java!\"</span>;</span><br><span class=\"line\">        System.out.println(greeting);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; greeting.length(); i++)</span><br><span class=\"line\">            System.out.print(<span class=\"string\">\"=\"</span>);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>","keywords":null,"cover":"/images/sprouting180319_1.png","content":null,"text":"❤  上手第一个Java程序，照着课本例子抄的，全程手写，结果终了执行的时候出了问题。<br>下面是我写的错误代码：  1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"英文录","slug":"sprouting180319","date":"2018-03-19T03:05:06.000Z","updated":"2018-04-04T07:03:42.000Z","comments":true,"path":"api/articles/sprouting180319.json","excerpt":"<p style=\"text-align: center;\">❤</p>\n\n<blockquote>\n<ul>\n<li><h3 id=\"Eden\"><a href=\"#Eden\" class=\"headerlink\" title=\"Eden\"></a>Eden</h3><h5 id=\"伊甸园；堆内存中新生代分为Eden-Suvivor\"><a href=\"#伊甸园；堆内存中新生代分为Eden-Suvivor\" class=\"headerlink\" title=\"伊甸园；堆内存中新生代分为Eden,Suvivor\"></a>伊甸园；堆内存中新生代分为Eden,Suvivor</h5><p>  Eden space is where objects are created. Life for them is all happy but eventually they’re chased out by a cherub into the wilderness of the young and later the old generation.</p>\n<p>  They are never allowed back in Eden space, they have to stay in the rough world of continuous tenuring until the Grim Collector comes for them.</p>\n<p>  However, unlike the original Eden, it is possible to die there. Well, I guess all metaphors break down under closer scrutiny.</p>","keywords":null,"cover":null,"content":null,"text":"❤Eden伊甸园；堆内存中新生代分为Eden,Suvivor  Eden space is where objects are created. Life for them is all happy but eventually they’re chased out by a c","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"一些关于Java要记住的话","slug":"sprouting180319b","date":"2018-03-19T08:44:36.000Z","updated":"2018-04-04T04:58:44.000Z","comments":true,"path":"api/articles/sprouting180319b.json","excerpt":"<p style=\"text-align: center;\">❤</p>\n\n<ul>\n<li><b>Data</b><ol>\n<li>类名用大驼峰，属性用小驼峰（对于java来说，大小写非常重要）</li>\n<li>源代码的文件名必须与公共类的名字相同，并用.java作为扩展名</li>\n<li>每个java应用程序必须有一个main函数","keywords":null,"cover":"/images/sprouting180319b_1.png","content":null,"text":"❤Data类名用大驼峰，属性用小驼峰（对于java来说，大小写非常重要）源代码的文件名必须与公共类的名字相同，并用.java作为扩展名每个java应用程序必须有一个main函数   每个句子必须以分号结束不要担心你注释的代码会膨胀你的可执行代码Java是一种强类型语言，记住数据类","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"设计技巧","slug":"sprouting180325","date":"2018-03-25T03:32:48.000Z","updated":"2018-04-13T01:43:33.000Z","comments":true,"path":"api/articles/sprouting180325.json","excerpt":"<p style=\"text-align: center;\">❤</p>\n\n<p><img src=\"/images/sprouting180325_1.png\" alt=\"\"></p>\n<h2 id=\"类的设计技巧\"><a href=\"#类的设计技巧\" class=\"headerlink\" title=\"类的设计技巧\"></a>类的设计技巧</h2><ul>\n<li><p>一定要保证数据私有</p>\n<ul>\n<li>这是最重要的；绝对不要破坏封装性。有时候，需要编写一个访问器方法或更改器方法，但是最好还是保持实例域的私有性。很多惨痛的经验告诉我们，数据的表示形式很可能会改变，但它们的使用方式却不会经常发生变化。当数据保持私有时，它们的表示形式的变化不会对类的使用者产生影响，即使出现bug也易于检测。</li>\n</ul>\n</li>\n<li><p>一定要对数据初始化</p>\n</li>\n<li>不要在类中使用过多的基本类型<ul>\n<li>如果存在多个属性具有一定联系的情况，最好将这几个属性构建成对象，以方便使用</li>\n</ul>\n</li>\n<li>不是所有的域都需要独立的域访问器和域更改器</li>\n<li>将职责过多的类进行分解</li>\n<li>类名和方法名要能够体现它们的职责</li>\n<li>优先使用不可变的类<ul>\n<li>更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改。其结果是不可预料的。如果类是不可变的，就可以安全地在多个线程间共享其对象  </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"继承的设计技巧\"><a href=\"#继承的设计技巧\" class=\"headerlink\" title=\"继承的设计技巧\"></a>继承的设计技巧</h2><ul>\n<li>将公共操作和域放在超类</li>\n<li>不要使用受保护的域</li>\n<li>使用继承实现“is-a”关系</li>\n<li>除非所有继承的方法都有意义，否则不要使用继承</li>\n<li>在覆盖方法时，不要改变预期的行为</li>\n<li>使用多态，而非类型信息</li>\n<li>不要过多的使用反射</li>\n</ul>","keywords":null,"cover":"/images/sprouting180325_1.png","content":null,"text":"❤ [Figure] 🍀From Clover https://aprilsx.github.io/2018/03/25/sprouting180325/ ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Object:所有类的超类","slug":"sprouting180326","date":"2018-03-26T02:35:36.000Z","updated":"2018-04-13T01:43:12.000Z","comments":true,"path":"api/articles/sprouting180326.json","excerpt":"<p style=\"text-align: center;\">❤</p>\n\n<h3 id=\"eaquals\"><a href=\"#eaquals\" class=\"headerlink\" title=\".eaquals()\"></a>.eaquals()</h3><p>用于检测一个对象是否等于另外一个对象，这个方法将判断两个对象是否具有相同的引用。设计评判标准：</p>\n<ul>\n<li>自反性</li>\n<li>对称性</li>\n<li>传递性</li>\n<li>一致性</li>\n</ul>\n<p>我们判断两个对象是否相等，主要得看这两个对象的状态是否相等。这样一来，我们一般会在类中重写equals()这个方法，以此来比较状态的一致性。<br>模版与注意事项如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">YourClass</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">eaquals</span><span class=\"params\">(Object otherObject)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 判断引用是否相同，如果内存的引用相同，那肯定是相同的</span></span><br><span class=\"line\">        <span class=\"comment\">// a quick test to see if the objects are identical.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == otherObject) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 2. 判断参数是否非空</span></span><br><span class=\"line\">        <span class=\"comment\">// must return false if the explicit parameter is null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (otherObject == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 3. 判断是否为同一类</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里需要看情况处理</span></span><br><span class=\"line\">        <span class=\"comment\">// * 子类能够拥有自己的相等概念，则对称性需求将强制采用getClass进行检测</span></span><br><span class=\"line\">        <span class=\"comment\">// ** 超类决定了相等的概念，那么使用instanceof判断是否是该超类的子类就可以了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getClass() != otherObject.getClass()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 4. 判断被比较的两个对象的状态是否一致</span></span><br><span class=\"line\">        <span class=\"comment\">// now we know 'otherObject' which 'non-null YourClass'</span></span><br><span class=\"line\">        YourClass other = (YourClass) otherObject;</span><br><span class=\"line\">        <span class=\"comment\">// 假设你的对象实例域有：name,salary,hireDay</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> name.eaquals(other.name) &amp;&amp; salary == other.salary &amp;&amp; hireDay.eaquals(other.hireDay);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>","keywords":null,"cover":null,"content":null,"text":"❤.eaquals()用于检测一个对象是否等于另外一个对象，这个方法将判断两个对象是否具有相同的引用。设计评判标准：自反性对称性传递性一致性我们判断两个对象是否相等，主要得看这两个对象的状态是否相等。这样一来，我们一般会在类中重写equals()这个方法，以此来比较状态的一致性。","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java3rd.log4j","slug":"sprouting180401","date":"2018-04-01T02:02:52.000Z","updated":"2018-04-04T04:55:47.000Z","comments":true,"path":"api/articles/sprouting180401.json","excerpt":"<p></p><p style=\"text-align: center;\">❤</p><p></p>\n<h3 id=\"What-is-the-log4j\"><a href=\"#What-is-the-log4j\" class=\"headerlink\" title=\"What is the log4j?\"></a>What is the log4j?</h3><h3 id=\"How-to-install\"><a href=\"#How-to-install\" class=\"headerlink\" title=\"How to install?\"></a>How to install?</h3><h3 id=\"How-to-use\"><a href=\"#How-to-use\" class=\"headerlink\" title=\"How to use?\"></a>How to use?</h3><h3 id=\"Config-Means\"><a href=\"#Config-Means\" class=\"headerlink\" title=\"Config Means\"></a>Config Means</h3>","keywords":null,"cover":null,"content":null,"text":"❤What is the log4j?How to install?How to use?Config Means<br>  参考文献：<br>🍀From Clover https://aprilsx.github.io/2018/04/01/sprouting180401/ ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java注释及文档","slug":"sprouting180402","date":"2018-04-02T10:11:56.000Z","updated":"2018-04-07T10:08:04.000Z","comments":true,"path":"api/articles/sprouting180402.json","excerpt":"<p></p><p style=\"text-align: center;\">❤</p><p></p>\n<h3 id=\"Javadoc工具\"><a href=\"#Javadoc工具\" class=\"headerlink\" title=\"Javadoc工具\"></a>Javadoc工具</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javadoc -d <span class=\"string\">\"说明文档准备放到哪儿\"</span> -doctitle <span class=\"string\">\"给说明文档起个标题\"</span> -author -version YourSourceCode.java</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体说明可以通过-help命令查看</span></span><br><span class=\"line\">javadoc -help</span><br></pre></td></tr></table></figure>\n<h3 id=\"如何去写文档注释\"><a href=\"#如何去写文档注释\" class=\"headerlink\" title=\"如何去写文档注释\"></a>如何去写文档注释</h3><ul>\n<li><a href=\"http://www.cnblogs.com/boring09/p/4274893.html\" target=\"_blank\" rel=\"noopener\">参考李舜阳博客—“如何写Java文档注释”</a></li>\n<li><a href=\"http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html#examples\" target=\"_blank\" rel=\"noopener\">官方英文详细文档</a></li>\n</ul>\n<h3 id=\"文档内注释参数使用说明\"><a href=\"#文档内注释参数使用说明\" class=\"headerlink\" title=\"文档内注释参数使用说明\"></a>文档内注释参数使用说明</h3><ul>\n<li><a href=\"http://www.runoob.com/java/java-documentation.html\" target=\"_blank\" rel=\"noopener\">参考Runoob</a></li>\n</ul>","keywords":null,"cover":null,"content":null,"text":"❤Javadoc工具1<br>2<br>3<br>4<br>javadoc -d \"说明文档准备放到哪儿\" -doctitle \"给说明文档起个标题\" -author -version YourSourceCode.java<br><br>// 具体说明可以通过-help命令查看","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java.字符串","slug":"sprouting180404","date":"2018-04-03T16:02:15.000Z","updated":"2018-04-13T01:42:41.000Z","comments":true,"path":"api/articles/sprouting180404.json","excerpt":"<p></p><p style=\"text-align: center;\">❤</p><p></p>\n<h3 id=\"字符串的比较\"><a href=\"#字符串的比较\" class=\"headerlink\" title=\"字符串的比较\"></a>字符串的比较</h3><ul>\n<li><p>compareTo() 和 compareToIgnoreCase()  </p>\n<ol>\n<li>两个字符数组依次从前开始比较，如果对象位置出现字符不同则返回两个字符的编码之差，后面的字符不再比较；</li>\n<li>如果两个字符数组的长度不一样，并且较短的数组和较长数组所有对应位置的字符都相同，则返回两个数组的长度之差。</li>\n</ol>\n</li>\n<li><p>“==”  </p>\n<ol>\n<li><p>利用“==”进行比较，如果比较的是基本类型，由于自动拆装箱的机制的存在，故能够直接比较两个值的大小。如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;</span><br><span class=\"line\">Integer j = <span class=\"number\">2</span>;</span><br><span class=\"line\">System.out.println(i==j);  <span class=\"comment\">//返回true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果比较的是对象类型，由于“==”只能用来比较对象的引用，故无法再用于比较值了。</p>\n</li>\n</ol>\n</li>\n<li><p>equals()</p>\n<ol>\n<li><p>由于String类重写了equals()方法，如下源码所示，因此能够进行值的比较。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">        String aString = (String)anObject;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (coder() == aString.coder()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> isLatin1() ? StringLatin1.equals(value, aString.value)</span><br><span class=\"line\">                              : StringUTF16.equals(value, aString.value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>而StringBuffer和StringBuilder的equals()方法等价于“==”，不具备值的比较能力</p>\n</li>\n</ol>\n</li>\n<li><p>regionMatches()</p>\n<ol>\n<li>比较两个字符串中各自的某个相同区域内，内容是否相同</li>\n<li>设置第一个参数能够控制比较时忽略大小写<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringRegionMatchTest</span></span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">      String first_str = <span class=\"string\">\"Welcome to Microsoft\"</span>;</span><br><span class=\"line\">      String second_str = <span class=\"string\">\"I work with microsoft\"</span>;</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> match1 = first_str.regionMatches(<span class=\"number\">11</span>, second_str, <span class=\"number\">12</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> match2 = first_str.regionMatches(<span class=\"keyword\">true</span>, <span class=\"number\">11</span>, second_str, <span class=\"number\">12</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\">      <span class=\"comment\">//第一个参数 true 表示忽略大小写区别</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"区分大小写返回值：\"</span> + match1);     <span class=\"comment\">// 返回false</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"不区分大小写返回值：\"</span> + match2);    <span class=\"comment\">// 返回true</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>","keywords":null,"cover":null,"content":null,"text":"❤字符串的比较compareTo() 和 compareToIgnoreCase()  两个字符数组依次从前开始比较，如果对象位置出现字符不同则返回两个字符的编码之差，后面的字符不再比较；如果两个字符数组的长度不一样，并且较短的数组和较长数组所有对应位置的字符都相同，则返回两个数","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java.数组","slug":"sprouting180407","date":"2018-04-07T05:11:34.000Z","updated":"2018-04-13T01:40:14.000Z","comments":true,"path":"api/articles/sprouting180407.json","excerpt":"<p></p><p style=\"text-align: center;\">❤</p><p></p>\n<blockquote>\n<p>直接对数组是比较麻烦的，最好是利用JDK中提供的工具类进行操作。这便要求我们第一步去处理数组，将数组转换为可变对象数组，然后再进行操作会变的更加方便。但是有时候我们还需要考虑数据的安全性，因此数组转换后还是需要再考虑其处理结果的存储形势。</p>\n</blockquote>\n<p><br></p>\n<h3 id=\"数组的排序及元素查找\"><a href=\"#数组的排序及元素查找\" class=\"headerlink\" title=\"数组的排序及元素查找\"></a>数组的排序及元素查找</h3><ul>\n<li><p>sort()</p>\n<ol>\n<li>利用Arrays工具类的sort()便可轻松实现对数组的排序。值得注意的是，该排序算法DualPivotQuicksort自JDK1.7之后再次做了优化。</li>\n<li><a href=\"https://stackoverflow.com/questions/20917617/whats-the-difference-of-dual-pivot-quick-sort-and-quick-sort\" target=\"_blank\" rel=\"noopener\">关于DualPivotQuicksort</a></li>\n</ol>\n</li>\n<li><p>parallelSort()</p>\n<ol>\n<li>并行排序在sort()再次进行了优化，主要考虑的是CPU资源占用问题。对线程的合理规划使得我们在处理大数据排序时又节省了一些时间。<a href=\"https://www.cnblogs.com/princessd8251/articles/5186704.html\" target=\"_blank\" rel=\"noopener\">大致比较结果</a></li>\n</ol>\n</li>\n<li><a href=\"https://www.cnblogs.com/whgk/p/6596787.html\" target=\"_blank\" rel=\"noopener\">Java实现7种排序</a></li>\n<li><p>binarySearch()</p>\n<ol>\n<li>在数组已排序完成的前提下！利用二分法查找能够快速获得想要查找的元素。</li>\n</ol>\n</li>\n<li><p>contains()</p>\n<ol>\n<li>查看数组中是否包含指定元素。</li>\n</ol>\n</li>\n</ul>","keywords":null,"cover":null,"content":null,"text":"❤直接对数组是比较麻烦的，最好是利用JDK中提供的工具类进行操作。这便要求我们第一步去处理数组，将数组转换为可变对象数组，然后再进行操作会变的更加方便。但是有时候我们还需要考虑数据的安全性，因此数组转换后还是需要再考虑其处理结果的存储形势。<br>数组的排序及元素查找sort()","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java.时间","slug":"sprouting180407b","date":"2018-04-07T10:01:18.000Z","updated":"2018-04-13T01:41:12.000Z","comments":true,"path":"api/articles/sprouting180407b.json","excerpt":"<p></p><p style=\"text-align: center;\">❤</p><br><img src=\"images/sprouting180407b_1.png\" alt=\"来自百度百科-格里高利历\"><p></p>\n<blockquote>\n<p>  时间的处理主要分为两种：<br>  一种作为量度主要被用来做计算，以ms为单位。<br>  另一种便是日期，被用来纪年。</p>\n</blockquote>\n<h3 id=\"时间的获取\"><a href=\"#时间的获取\" class=\"headerlink\" title=\"时间的获取\"></a>时间的获取</h3><ul>\n<li><p>Date()</p>\n<ol>\n<li><p>Date类中有好多废弃的方法，主要是因为这些方法破坏了类的封装性，使得原来被创建的Date对象再使用这些方法过后被改变。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Date();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>所以建议使用LocalDate</p>\n</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>LocalDate()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDate.now();</span><br><span class=\"line\">LocalTime.now();</span><br><span class=\"line\">LocalDateTime.now();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Calendar()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Calendar.getInstance();</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Calendar用来处理日期很方便</li>\n</ol>\n</li>\n<li><p>时间戳</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.currentTimeMillis()</span><br></pre></td></tr></table></figure>\n</li>\n</ul>","keywords":null,"cover":"images/sprouting180407b_1.png","content":null,"text":"❤<br> [Figure] 🍀From Clover https://aprilsx.github.io/2018/04/07/sprouting180407b/ ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Eclipse Oxygen迷途之旅","slug":"sprouting180408","date":"2018-04-08T09:32:54.000Z","updated":"2018-04-13T01:41:38.000Z","comments":true,"path":"api/articles/sprouting180408.json","excerpt":"<p style=\"text-align: center;\">❤</p>\n\n<h3 id=\"Eclipse-Oxygen安装JavaEE\"><a href=\"#Eclipse-Oxygen安装JavaEE\" class=\"headerlink\" title=\"Eclipse Oxygen安装JavaEE\"></a>Eclipse Oxygen安装JavaEE</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/YIII_TIAN/article/details/78991782\" target=\"_blank\" rel=\"noopener\">移步“YIII_TIAN”的这篇博客的安装部分</a></p>\n</blockquote>\n<p><br></p>\n<h3 id=\"Eclipse-Oxygen创建第一个Servlet项目\"><a href=\"#Eclipse-Oxygen创建第一个Servlet项目\" class=\"headerlink\" title=\"Eclipse Oxygen创建第一个Servlet项目\"></a>Eclipse Oxygen创建第一个Servlet项目</h3><blockquote>\n<p><a href=\"https://www.cnblogs.com/kangjianwei101/p/5621750.html\" target=\"_blank\" rel=\"noopener\">移步“迷路的国王”的《Eclipse For JavaEE安装、配置、测试(win7_64bit)》</a></p>\n</blockquote>\n<p><br></p>\n<h3 id=\"Eclipse-Oxygen代码折叠-Collapes-All-展开-Expend-All-快捷键设置\"><a href=\"#Eclipse-Oxygen代码折叠-Collapes-All-展开-Expend-All-快捷键设置\" class=\"headerlink\" title=\"Eclipse Oxygen代码折叠(Collapes All)/展开(Expend All)快捷键设置\"></a>Eclipse Oxygen代码折叠(Collapes All)/展开(Expend All)快捷键设置</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/dliyuedong/article/details/12873651\" target=\"_blank\" rel=\"noopener\">移步“李跃东”的《eclipse代码折叠/展开之笔记本快捷键设置》</a><br>Mac下建议更改快捷键为 ‘control’ 加 ‘shift’ 加 ‘-‘ 和 ‘+’的组合，如图<br><img src=\"images/sprouting180408_1.png\" alt=\"\"><br><img src=\"images/sprouting180408_2.png\" alt=\"\"></p>\n</blockquote>","keywords":null,"cover":"images/sprouting180408_1.png","content":null,"text":"❤Eclipse Oxygen安装JavaEE移步“YIII_TIAN”的这篇博客的安装部分<br>Eclipse Oxygen创建第一个Servlet项目移步“迷路的国王”的《Eclipse For JavaEE安装、配置、测试(win7_64bit)》<br>Eclipse ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java.方法","slug":"sprouting180410","date":"2018-04-10T12:05:20.000Z","updated":"2018-04-13T01:41:49.000Z","comments":true,"path":"api/articles/sprouting180410.json","excerpt":"<p></p><p style=\"text-align: center;\">❤</p><p></p>\n<h1 id=\"关于方法\"><a href=\"#关于方法\" class=\"headerlink\" title=\"关于方法\"></a>关于方法</h1><p><br></p>\n<h3 id=\"什么是方法？\"><a href=\"#什么是方法？\" class=\"headerlink\" title=\"什么是方法？\"></a>什么是方法？</h3><blockquote>\n<p>编程语言中所说的方法，指的是能够处理事务的代码块。一般具有独立性，重用性，封装性等特点。C语言中叫它函数，Java中叫它方法。在面向对象的编程思想中，你也可以理解它为一种功能，编程者的你就好比上帝，你想让鸟会飞，便给它翅膀；你想让鱼会有，便给它尾鳍。</p>\n</blockquote>\n<p><br></p>\n<h3 id=\"方法长什么样子？\"><a href=\"#方法长什么样子？\" class=\"headerlink\" title=\"方法长什么样子？\"></a>方法长什么样子？</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修饰符  返回值类型  方法名（参数类型<span class=\"number\">1</span> 参数<span class=\"number\">1</span>, 参数类型<span class=\"number\">2</span> 参数<span class=\"number\">2</span>, ...）&#123;</span><br><span class=\"line\">    执行语句</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> 返回值;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最经典的便是main这个方法了<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"给鸟按翅膀，给鱼按鳍。\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// return;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所以方法里我们要关心下这些地方:</p>\n<ul>\n<li>修饰符<ul>\n<li>对访问权限进行限定。本质就是谁可以用，谁不能用的问题。</li>\n<li>控制内存空间区域存储的分配。</li>\n</ul>\n</li>\n<li>返回值类型<ul>\n<li>用于限定方法的返回值的数据类型。</li>\n</ul>\n</li>\n<li>方法名<ul>\n<li>起名字是有讲究的，比如setXXX，getXXX，构造器方法等等…</li>\n</ul>\n</li>\n<li>参数类型<ul>\n<li>用于接收调用方法时传入的数据</li>\n</ul>\n</li>\n<li>return关键字<ul>\n<li>用于结束方法以返回给调用者，在适当的时候可以提前结束。</li>\n</ul>\n</li>\n<li>返回值<ul>\n<li>被return返回的值，值就给了调用者。</li>\n</ul>\n</li>\n</ul>\n<p><br><br>","keywords":null,"cover":"/images/sprouting180410_1.png","content":null,"text":"❤关于方法<br>什么是方法？编程语言中所说的方法，指的是能够处理事务的代码块。一般具有独立性，重用性，封装性等特点。C语言中叫它函数，Java中叫它方法。在面向对象的编程思想中，你也可以理解它为一种功能，编程者的你就好比上帝，你想让鸟会飞，便给它翅膀；你想让鱼会有，便给它尾鳍。","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java.接口","slug":"sprouting180411","date":"2018-04-11T12:12:24.000Z","updated":"2018-04-13T01:45:01.000Z","comments":true,"path":"api/articles/sprouting180411.json","excerpt":"<p></p><p style=\"text-align: center;\">❤</p><br><br><p></p>\n<h1 id=\"接口技术\"><a href=\"#接口技术\" class=\"headerlink\" title=\"接口技术\"></a>接口技术</h1><p><br></p>\n<h3 id=\"接口技术是什么？\"><a href=\"#接口技术是什么？\" class=\"headerlink\" title=\"接口技术是什么？\"></a>接口技术是什么？</h3><ul>\n<li>接口技术主要用来描述类具有什么功能，而并不给出每个功能的具体实现。其具体功能的实现，应该交给遵从接口描述的类。一个类可以实现多个接口。接口中声明的方法默认使用的是public修饰符，也必须是public，这个很容易理解，因为你写接口就是让别人去实现的，你要是私有了，还有什么用！</li>\n</ul>","keywords":null,"cover":null,"content":null,"text":"❤<br><br>接口技术<br>接口技术是什么？接口技术主要用来描述类具有什么功能，而并不给出每个功能的具体实现。其具体功能的实现，应该交给遵从接口描述的类。一个类可以实现多个接口。接口中声明的方法默认使用的是public修饰符，也必须是public，这个很容易理解，因为你写接","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java.lambda","slug":"sprouting180412","date":"2018-04-12T06:27:09.000Z","updated":"2018-04-13T01:35:02.000Z","comments":true,"path":"api/articles/sprouting180412.json","excerpt":"<p></p><p style=\"text-align: center;\">❤</p><br><br><p></p>\n<h1 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a>lambda表达式</h1><p><a href=\"https://www.zhihu.com/question/27448188\" target=\"_blank\" rel=\"noopener\">数学中，带参数变量的表达式被称为lambda表达式。这背后有一小段故事。</a></p>\n<p><br></p>\n<h3 id=\"为什么引入lambda表达式？\"><a href=\"#为什么引入lambda表达式？\" class=\"headerlink\" title=\"为什么引入lambda表达式？\"></a>为什么引入lambda表达式？</h3><ul>\n<li>道理具简单，为了代码简洁，可读性高。lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。注意“以后”两个字，它意味着你在想用它的时候，在调它。这岂不是很方便么！了解Objective-C的一定会第一时间想到，这不就是block吗？是的，确实是一个意思。</li>\n</ul>","keywords":null,"cover":null,"content":null,"text":"❤<br><br>lambda表达式数学中，带参数变量的表达式被称为lambda表达式。这背后有一小段故事。<br>为什么引入lambda表达式？道理具简单，为了代码简洁，可读性高。lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。注意“以后”两个字，它意味着你在","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java.代理模式(Proxy)","slug":"sprouting180413","date":"2018-04-13T02:30:30.000Z","updated":"2018-04-13T06:45:55.000Z","comments":true,"path":"api/articles/sprouting180413.json","excerpt":"","keywords":null,"cover":null,"content":"<p></p><p style=\"text-align: center;\">❤</p><p></p>\n<h3 id=\"代理模式是什么？\"><a href=\"#代理模式是什么？\" class=\"headerlink\" title=\"代理模式是什么？\"></a>代理模式是什么？</h3><blockquote>\n<p>代理(Proxy)是一种设计模式，提供了对目标对象另外的访问方式；即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。</p>\n<p>这里使用到编程中的一个思想：不要随意去修改别人已经写好的代码或者方法，如果需改修改，可以通过代理的方式来扩展该方法</p>\n</blockquote>\n<p><br></p>\n<h3 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h3><blockquote>\n<p>静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类.</p>\n<ul>\n<li>实现思路<ol>\n<li>创建公共父类或接口，使代理人和被代理人具有公共方法</li>\n<li>代理类中设置方法获取被代理对象</li>\n<li>代理类中重写被代理类中需要被扩展或更改的方法</li>\n<li>应用时，将被代理对象作为参数传递给代理对象，完成代理</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>代码部分<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Part.1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IUserDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Part.2 and .3</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span> <span class=\"keyword\">implements</span> <span class=\"title\">IUserDao</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Run as 10km/h! Too slow!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">IUserDao</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用父类或接口来接受对象，降低耦合度</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> IUserDao target;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDaoProxy</span><span class=\"params\">(IUserDao target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        target.run();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Propxy high up the speed to 20km/h! Fine!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Part.4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    UserDaoProxy proxy = <span class=\"keyword\">new</span> UserDaoProxy(<span class=\"keyword\">new</span> UserDao());</span><br><span class=\"line\">        proxy.run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"动态代理（JDK代理、接口代理）\"><a href=\"#动态代理（JDK代理、接口代理）\" class=\"headerlink\" title=\"动态代理（JDK代理、接口代理）\"></a>动态代理（JDK代理、接口代理）</h3><blockquote>\n<p>动态代理的代理对象不需要实现接口，它是通过JDK的API，动态的在内存中构建代理对象(需要我们指定创建代理对象／目标对象实现的接口的类型)</p>\n<p>动态代理中用到了invoke()，这是反射方面的知识，如果对反射机制没有一个认识的话，动态代理部分逻辑的实现会比较难理解！</p>\n</blockquote>\n<ul>\n<li><p>实现思路</p>\n<ol>\n<li>创建公共父类或接口，使代理人和被代理人具有公共方法</li>\n<li>设计代理工厂类，提供获取代理对象的方法。方法中主要利用Proxy.newProxyInstance()去创建代理实例，并实现对被代理类功能的重写或扩展</li>\n<li>创建被代理对象，通过代理工厂类获取代理对象，调用代理方法，完成代理</li>\n</ol>\n</li>\n<li><p>代码部分</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Part.1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IUserDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Part.2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ProxyFactory</span><span class=\"params\">(Object target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getProxyInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Proxy.newProxyInstance(</span><br><span class=\"line\">                <span class=\"comment\">// 参数1: loader</span></span><br><span class=\"line\">                <span class=\"comment\">// 为了获得原对象的类加载器</span></span><br><span class=\"line\">                target.getClass().getClassLoader(), </span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 参数2: interfaces</span></span><br><span class=\"line\">                <span class=\"comment\">// 为了获得原对象所实现的接口类型</span></span><br><span class=\"line\">                target.getClass().getInterfaces(), </span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 参数3: new InvocationHandler</span></span><br><span class=\"line\">                <span class=\"comment\">// 事件处理器</span></span><br><span class=\"line\">                <span class=\"comment\">// 执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"执行目标对象的方法并扩展\"</span>);</span><br><span class=\"line\">                        Object returnValue = method.invoke(target, args);</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"Propxy high up the speed to 20km/h! Fine!\"</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> returnValue;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Part.3</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    UserDao target = <span class=\"keyword\">new</span> UserDao();</span><br><span class=\"line\">    System.out.println(target.getClass());</span><br><span class=\"line\">    </span><br><span class=\"line\">    IUserDao proxy = (IUserDao) <span class=\"keyword\">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class=\"line\">    System.out.println(proxy.getClass());</span><br><span class=\"line\">    </span><br><span class=\"line\">    proxy.run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"Cglib代理（子类代理）\"><a href=\"#Cglib代理（子类代理）\" class=\"headerlink\" title=\"Cglib代理（子类代理）\"></a>Cglib代理（子类代理）</h3><ul>\n<li><a href=\"https://www.cnblogs.com/cenyu/p/6289209.html\" target=\"_blank\" rel=\"noopener\">请进入传送门</a></li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>  参考文献：<br>  [ 1 ] <a href=\"https://www.cnblogs.com/cenyu/p/6289209.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/cenyu/p/6289209.html</a><br>  [ 2 ] Java核心技术I p190-207<br><br></p>\n</blockquote>\n<p>🍀From Clover <a href=\"https://aprilsx.github.io/2018/04/13/sprouting180413/\">https://aprilsx.github.io/2018/04/13/sprouting180413/</a> </p>\n","text":"❤代理模式是什么？代理(Proxy)是一种设计模式，提供了对目标对象另外的访问方式；即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。这里使用到编程中的一个思想：不要随意去修改别人已经写好的代码或者方法，如果需改修改","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java.反射","slug":"sprouting180413b","date":"2018-04-13T05:53:16.000Z","updated":"2018-04-13T08:50:39.000Z","comments":true,"path":"api/articles/sprouting180413b.json","excerpt":"","keywords":null,"cover":null,"content":"<p></p><p style=\"text-align: center;\">❤</p><br><br><p></p>\n<h3 id=\"什么是反射？\"><a href=\"#什么是反射？\" class=\"headerlink\" title=\"什么是反射？\"></a>什么是反射？</h3><blockquote>\n<p>能够分析类能力的程序称为反射（reflection）。反射库提供了一个非常丰富且精心设计的工具类，以便编写能够动态操纵Java代码的程序。特别是在设计或运行中添加新类时，能够快速地应用开发工具动态地查询新添加类的能力。</p>\n</blockquote>\n<p><br></p>\n<h3 id=\"反射机制可以用来做什么？\"><a href=\"#反射机制可以用来做什么？\" class=\"headerlink\" title=\"反射机制可以用来做什么？\"></a>反射机制可以用来做什么？</h3><ul>\n<li>反射是一种功能强大且复杂的机制，使用它的主要人员是工具构造者，而不是应用程序员。<ul>\n<li>在运行时分析类</li>\n<li>在运行时查看对象</li>\n<li>实现通用的数组操作代码</li>\n<li>利用Method对象</li>\n</ul>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"Class类\"><a href=\"#Class类\" class=\"headerlink\" title=\"Class类\"></a>Class类</h3><blockquote>\n<p>在程序运行期间，Java运行时系统时钟为所有的对象维护一个被称为<b>运行时</b>的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行，这些信息可以通过专门的Java类来访问，而保存这些信息的类就是Class。</p>\n</blockquote>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Class对象方法测试</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">String <span class=\"built_in\">str</span> = new String();</span><br><span class=\"line\"></span><br><span class=\"line\">Class <span class=\"built_in\">className</span> = <span class=\"built_in\">str</span>.getClass();</span><br><span class=\"line\">System.out.println(<span class=\"built_in\">className</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"built_in\">className</span>.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"built_in\">className</span>.getSuperclass());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(Arrays.<span class=\"built_in\">toString</span>(<span class=\"built_in\">className</span>.getDeclaredMethods()));</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(Arrays.<span class=\"built_in\">toString</span>(<span class=\"built_in\">className</span>.getDeclaredClasses()));</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"built_in\">className</span>.getModifiers());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"built_in\">className</span>.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(Arrays.<span class=\"built_in\">toString</span>(<span class=\"built_in\">className</span>.getTypeParameters()));</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"built_in\">className</span>.getTypeName());</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"利用反射搞点事儿\"><a href=\"#利用反射搞点事儿\" class=\"headerlink\" title=\"利用反射搞点事儿\"></a>利用反射搞点事儿</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个例子利用反射实现了泛型数组的拷贝，很好的例子！</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">goodCopyOf</span><span class=\"params\">(Object a, <span class=\"keyword\">int</span> newLength)</span> </span>&#123;</span><br><span class=\"line\">    Class acl = a.getClass();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!acl.isArray()) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Class componetType = acl.getComponentType();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = Array.getLength(a);</span><br><span class=\"line\">    Object newArray = Array.newInstance(componetType, newLength);</span><br><span class=\"line\">    System.arraycopy(a, <span class=\"number\">0</span>, newArray, <span class=\"number\">0</span>, Math.min(length, newLength));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"调用任意方法\"><a href=\"#调用任意方法\" class=\"headerlink\" title=\"调用任意方法\"></a>调用任意方法</h3><p>在上代码之前，首先我们要清楚一个概念关于Method类。Method类类似于C语言中的函数指针，我们可以利用函数指针执行任意函数。</p>\n<ul>\n<li>假如我们已经获得了一个函数指针，那么如何去调用相对应的函数呢？这时候，反射机制就可以帮到我们，Mathod类中提供了一个invoke()方法，它便是利用反射机制来实现通过函数指针调用对应的函数。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 下面是invoke()方法签名，它就长这个样子</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 参数1: </span></span><br><span class=\"line\"><span class=\"comment\"> *      是一个隐式参数。</span></span><br><span class=\"line\"><span class=\"comment\"> *      对于静态方法，第一个参数可以被忽略，即可以将它设置为null</span></span><br><span class=\"line\"><span class=\"comment\"> * 剩余参数:</span></span><br><span class=\"line\"><span class=\"comment\"> *      是显示参数，如果没有显示参数就传递一个null</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 好像很难理解，我们来对照着获取函数指针的方法来看调用函数指针的方法就会明白</span></span><br><span class=\"line\"><span class=\"comment\"> *      String s = \"1\";</span></span><br><span class=\"line\"><span class=\"comment\"> *      Method m = s.getClass().getMethod(name, parameterTypes);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">Object <span class=\"title\">invoke</span><span class=\"params\">(Object obj, Object... args)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>现在我们知道了如何去调用函数指针对应的函数方法了。那么，另一问题？我们如何获得一个陌生类中的函数指针呢？<ol>\n<li>可以通过Class类中的getDeclareMethods方法，在返回的结果去找你想要的Method</li>\n<li>也可以通过调用这个类的getMethod方法得到</li>\n</ol>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>  参考文献：<br>  [ 1 ] Java核心技术I p190-207<br><br></p>\n</blockquote>\n<p>🍀From Clover <a href=\"https://aprilsx.github.io/2018/04/13/sprouting180413b/\">https://aprilsx.github.io/2018/04/13/sprouting180413b/</a> </p>\n","text":"❤<br><br>什么是反射？能够分析类能力的程序称为反射（reflection）。反射库提供了一个非常丰富且精心设计的工具类，以便编写能够动态操纵Java代码的程序。特别是在设计或运行中添加新类时，能够快速地应用开发工具动态地查询新添加类的能力。<br>反射机制可以用来做什么？","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]},{"title":"Java.集合","slug":"sprouting180413c","date":"2018-04-13T09:43:24.000Z","updated":"2018-04-14T05:49:15.000Z","comments":true,"path":"api/articles/sprouting180413c.json","excerpt":"","keywords":null,"cover":"images/sprouting180413c_1.png","content":"<p></p><p style=\"text-align: center;\">❤</p><br><br><p></p>\n<h3 id=\"集合的出现是用来解决什么问题？\"><a href=\"#集合的出现是用来解决什么问题？\" class=\"headerlink\" title=\"集合的出现是用来解决什么问题？\"></a>集合的出现是用来解决什么问题？</h3><p>在实现方法的过程中，选择不同的数据结构会导致我们的实现风格以及性能存在着很大差异。所以在选择数据结构的时候，我们往往会考虑以下一些问题:</p>\n<ul>\n<li>我们需要快速地搜索成千上万的有序的数据项吗？</li>\n<li>我们需要快速地在有序的序列中间插入元素或删除元素吗？</li>\n<li>我们需要建立键与值之间的关联吗？</li>\n<li>…</li>\n</ul>\n<p><br></p>\n<h3 id=\"数据结构的相关知识\"><a href=\"#数据结构的相关知识\" class=\"headerlink\" title=\"数据结构的相关知识\"></a>数据结构的相关知识</h3><ol>\n<li><a href=\"https://blog.csdn.net/juanqinyang/article/details/51354293\" target=\"_blank\" rel=\"noopener\">参看“yang蜗牛”的博客了解队列——队列(queue)</a>。队列的两种实现分别是:<ul>\n<li>循环队列<br>  基于循环队列实现的循环数组是一个有界集合，即容量有限。</li>\n<li>链表<br>  基于链式队列实现的链表，不需要考虑队列是否已满，只要内存足够就可以一直分配空间。如果程序中要收集的对象数量没有上限，就最好使用链表。</li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/kay5804/article/details/5925555\" target=\"_blank\" rel=\"noopener\">参看“jspwind”的博客了解散列-散列(hash)</a><ul>\n<li>散列表(hashtable)可以快速查找所需要的对象</li>\n<li>散列表为每个对象计算了一个整数，称为散列码(hash code)</li>\n<li>在Java中，散列表用链表数组实现，每个列表被称为桶(bucket)</li>\n<li>桶数指的是用于收集具有相同散列值的数目<br>如果想要查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余得到保存这个元素的桶的索引，最后就可以很快找到这个元素了。这就是散列的用处。</li>\n</ul>\n</li>\n</ol>\n<p><br></p>\n<h3 id=\"迭代器（Iterator）\"><a href=\"#迭代器（Iterator）\" class=\"headerlink\" title=\"迭代器（Iterator）\"></a>迭代器（Iterator）</h3><ol>\n<li>迭代器对元素的访问顺序取决于被访问集合的类型，如ArrayList的访问是顺序的，又如HashSet的访问是无序的</li>\n<li>Iterator与Enumeration有类似方法，它们作用是一样的，但更多人喜欢Iterator，因为名字短</li>\n<li>Java迭代器中的查找操作与位置变更是紧密相连的，可以将Java迭代器认为是位于两个元素之间。当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。</li>\n<li>有个有用的推论是，可以将Iterator.next与InputStream.read看作为等效的。从数据流中读取一个字节，都会会自动地“消耗掉”这个字节。</li>\n<li>在Java中，参照第3点，迭代器的操作类似于“光标”的操作，绘制迭代器示意图对于理解迭代器的操作逻辑很有帮助</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">迭代器示意图例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">/ABC</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">A/BC</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">AX/BC</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 对应迭代器示意图的代码实现部分</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; a = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    a.add(<span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">    a.add(<span class=\"string\">\"B\"</span>);</span><br><span class=\"line\">    a.add(<span class=\"string\">\"C\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 获取迭代器</span></span><br><span class=\"line\">    ListIterator&lt;String&gt; aIter = a.listIterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( aIter.hasNext() ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( aIter.hasNext() ) &#123;</span><br><span class=\"line\">            aIter.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        aIter.add(<span class=\"string\">\"X\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"集合框架中接口的继承关系\"><a href=\"#集合框架中接口的继承关系\" class=\"headerlink\" title=\"集合框架中接口的继承关系.\"></a>集合框架中接口的继承关系.</h3><p><a href=\"https://www.cnblogs.com/jing99/p/7057245.html\" target=\"_blank\" rel=\"noopener\">图片引用“kosamino”的博客</a><br><a href=\"https://www.cnblogs.com/jing99/p/7057245.html\" target=\"_blank\" rel=\"noopener\"><img src=\"images/sprouting180413c_1.png\" alt=\"\"></a></p>\n<p><br></p>\n<blockquote>\n<p>  参考文献：<br>  [ 1 ] Java核心技术I p345-<br>  [ 2 ] <a href=\"https://blog.csdn.net/juanqinyang/article/details/51354293\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/juanqinyang/article/details/51354293</a><br><br></p>\n</blockquote>\n<p>🍀From Clover <a href=\"https://aprilsx.github.io/2018/04/13/sprouting180413c/\">https://aprilsx.github.io/2018/04/13/sprouting180413c/</a> </p>\n","text":"❤<br><br>集合的出现是用来解决什么问题？在实现方法的过程中，选择不同的数据结构会导致我们的实现风格以及性能存在着很大差异。所以在选择数据结构的时候，我们往往会考虑以下一些问题:我们需要快速地搜索成千上万的有序的数据项吗？我们需要快速地在有序的序列中间插入元素或删除元素吗？","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"sprouting","slug":"sprouting","count":17,"path":"api/tags/sprouting.json"}]}]}